---
url: [/post/authentication-va-authorization-trong-blazor]
title: "Authentication và Authorization trong Blazor"
$attribute: PostMetadata(Id = "8d3c92bd-03a1-4b5f-84e6-7ae5db8302a0", Title = "Authentication và Authorization trong Blazor", Category = "Blazor", LastModified = "21-10-2025")
$layout: BlogContentLayout
---

Từ .NET 8 trở đi, Microsoft hợp nhất hai mô hình Server và Blazor WebAssembly thành 
Blazor Web App, cho phép Prerendering trên server để cải thiện SEO và tốc độ tải trang. 
Tuy nhiên, điều này làm cho việc xử lý Authentication trở nên phức tạp hơn vì trạng 
thái đăng nhập ban đầu được render ở server (nơi chưa có token), nhưng sau đó cần 
đồng bộ với client khi interactive được kích hoạt.

Bài viết này sẽ hướng dẫn chi tiết cách triển khai **Authentication** và **Authorization** 
trong **Blazor Web App** sử dụng:
- ASP.NET Core Identity.
- Federation (OIDC/OAuth2 – đăng nhập với Google, GitHub,...)
- BFF pattern (Backend For Frontend) – mô hình được Microsoft khuyến nghị sử dụng.

> 📘 Nếu bạn chưa quen với `Authentication` và `Authorization` trong .NET, 
hãy xem lại bài viết [Authentication và Authorization trong .NET](/post/authentication-va-authorization-trong-net)

# Tổng quan về Authentication trong Blazor Web App

## Claims-based Identity

Blazor sử dụng mô hình **Claims-based Identity**, nơi
mỗi người dùng được biểu diễn bởi một `ClaimsPrincipal` chứa các `Claim`.

> 💡 Để hiểu rõ hơn về mô hình Claims-based Identity trong .NET hãy 
đọc [bài viết này](/post/authentication-va-authorization-trong-net#kien-truc-authentication-va-authorization-trong.net)

Các claim này được lưu trong `ClaimsPrincipal` và có thể truy cập thông 
qua `AuthenticationStateProvider` như sau:

```markup
@page "/me"
@inject AuthenticationStateProvider AuthStateProvider

<h3>Thông tin người dùng</h3>

@code {
    private string? userName;
    private string? email;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity?.IsAuthenticated == true)
        {
            userName = user.Identity.Name;
            email = user.FindFirst(c => c.Type == "email")?.Value;
        }
    }
}
```

Hoặc đơn giản hơn là dùng Cascading Parameter:
```markup
@code {
    [CascadingParameter] 
    private Task<AuthenticationState>? authenticationState { get; set; }

    private async Task DoSomething()
    {
        var authState = await authenticationState;
        var user = authState?.User;
        if (user?.Identity?.IsAuthenticated == true)
        {
            // Xử lý logic
        }
    }
}
```

## Render Mode và Authentication

Blazor Web App hỗ trợ nhiều render mode khác nhau: Static SSR, Interactive Server, 
Interactive WebAssembly và Interactive Auto. Mỗi mode ảnh hưởng đến cách xử lý authentication: 

| Render Mode | Mô tả | Cơ chế Authentication |
|--------------|--------|------------------------|
| **Static SSR** | UI được render tĩnh trên server. | Sử dụng HttpContext.User (cookie-based), xử lý bởi ASP.NET Core pipeline. Không render nếu unauthorized. |
| **Server** | UI được render và xử lý sự kiện trên server qua **SignalR**. | Authentication qua circuit SignalR; trạng thái duy trì trong circuit lifetime, với revalidation định kỳ. |
| **WebAssembly (WASM)** | Ứng dụng chạy hoàn toàn trên trình duyệt. | Trạng thái được deserialize từ server; client không enforce bảo mật tuyệt đối. |
| **Auto** | Bắt đầu với Server/SSR, chuyển sang WASM khi client tải xong. | Kết hợp cả hai; cần bảo mật cả component attribute và API endpoints. |


Để persist và revalidate authentication state thì:
- Server sử dụng `RevalidatingServerAuthenticationStateProvider` hoặc `PersistingRevalidatingAuthenticationStateProvider`.
- Client sử dụng `PersistentAuthenticationStateProvider`.

Hai provider này kết hợp với `PersistentComponentState` để persist trạng thái từ server qua client.

# Authentication không dùng BFF (Non-BFF) - Không khuyến nghị

Non-BFF (client-side OIDC với PKCE) chỉ phù hợp cho standalone Blazor WASM 
(không có server host). Trong Blazor Web App, nó gây xung đột với prerendering 
và kém bảo mật (token lưu ở browser, dễ bị XSS).

Microsoft không khuyến nghị cho production vì rủi ro bảo mật cao. Nếu vẫn dùng, 
cần tắt prerendering và cấu hình OIDC trực tiếp trên client, nhưng bài viết này ưu tiên 
BFF theo khuyến nghị của Microsoft.

# Authentication với BFF

Backend for Frontend (BFF) là pattern được Microsoft khuyến nghị cho Blazor Web App, 
nơi server xử lý toàn bộ OIDC flow, lưu token an toàn trên server và client chỉ dùng 
HttpOnly cookie. Điều này đảm bảo bảo mật cao (token không lộ trên browser), 
tương thích prerendering và hoạt động với tất cả render mode.

## Luồng hoạt động

<div class="mermaid">
sequenceDiagram
    participant U as User
    participant B as Browser (Blazor Client)
    participant S as Server (BFF Host)
    participant IDP as Identity Provider
    participant API as Protected API
    U->>B: Truy cập ứng dụng
    B->>S: Gửi request (prerender)
    S->>IDP: Redirect đến IDP nếu unauthorized
    IDP->>U: Form đăng nhập
    U->>IDP: Nhập thông tin xác thực
    IDP-->>S: Trả Authorization Code
    S->>IDP: Gửi Code + Client Secret lấy Token
    IDP-->>S: Trả Access/ID/Refresh Token
    S-->>B: Set HttpOnly Cookie
    B->>S: Request tiếp theo kèm Cookie
    S->>API: Gọi API thay mặt user bằng Bearer token
</div>

- Token chỉ tồn tại ở server.
- Client gọi API nội bộ qua BFF proxy để tránh lộ token.
- Prerendering có thể đọc `HttpContext.User` ngay nên có thể render chính xác.

## Triển khai

### 1. Cài đặt package (Server Project)

```bash
dotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect
dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
```

### 2. Cấu hình Identity (Server Project)

```csharp
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(connectionString));

builder.Services.AddIdentity<ApplicationUser, IdentityRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddDefaultTokenProviders();
```

### 3. Cấu hình Federation với External Providers

Thêm external providers như Google hoặc GitHub trong `Program.cs` ở Server project:
```csharp
// Google
builder.Services.AddAuthentication().AddGoogle(options =>
{
    options.ClientId = configuration["Oidc:ClientId"];
    options.ClientSecret = configuration["Oidc:ClientSecret"];
});

// GitHub (sử dụng OIDC)
builder.Services.AddAuthentication().AddGitHub(options =>
{
    options.ClientId = configuration["GitHub:ClientId"];
    options.ClientSecret = configuration["GitHub:ClientSecret"];
    options.Scope.Add("user:email");
});
```

### 4. Cấu hình OIDC cho BFF (Server Project)

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorComponents()
    .AddInteractiveWebAssemblyComponents();

builder.Services.AddScoped<AuthenticationStateProvider, PersistingAuthenticationStateProvider>();
builder.Services.AddCascadingAuthenticationState();
builder.Services.AddAuthorization();

JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();
builder.Services.AddAuthentication(options =>
{
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme;
})
.AddCookie(options =>
{
    options.Cookie.HttpOnly = true;
    options.Cookie.SameSite = SameSiteMode.Strict;
    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
})
.AddOpenIdConnect(options =>
{
    builder.Configuration.Bind("Oidc", options);
    options.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.SaveTokens = true; // Lưu token ở server để gọi API
    options.GetClaimsFromUserInfoEndpoint = true;
    options.Scope.Add("openid");
    options.Scope.Add("profile");
    options.Scope.Add("email");

    options.ClaimActions.MapJsonKey("sub", "sub");
    options.ClaimActions.MapUniqueJsonKey(ClaimTypes.NameIdentifier, "sub");
    options.ClaimActions.MapUniqueJsonKey(ClaimTypes.Email, "email");
    options.ClaimActions.MapUniqueJsonKey("picture", "picture");

    options.TokenValidationParameters.NameClaimType = ClaimTypes.Email;
});

builder.Services.ConfigureCookieOidcRefresh(
    CookieAuthenticationDefaults.AuthenticationScheme,
    OpenIdConnectDefaults.AuthenticationScheme);

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseWebAssemblyDebugging();
}

app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseAntiforgery();

app.UseAuthentication();
app.UseAuthorization();

app.MapRazorComponents<App>()
    .AddInteractiveWebAssemblyRenderMode()
    .AddAdditionalAssemblies(typeof(Blogtify.Client._Imports).Assembly);

app.MapLoginAndLogout();
app.Run();
```


```csharp
internal static class LoginLogoutEndpointRouteBuilderExtensions
{
    internal static IEndpointConventionBuilder MapLoginAndLogout(this IEndpointRouteBuilder endpoints)
    {
        var group = endpoints.MapGroup("authentication");

        group.MapGet("/login", (string? returnUrl) => TypedResults.Challenge(GetAuthProperties(returnUrl)))
            .AllowAnonymous();

        group.MapPost("/logout", async (HttpContext context, [FromQuery] string? returnUrl) =>
        {
            var props = GetAuthProperties(returnUrl);

            var oidcOptionsMonitor = context.RequestServices.GetRequiredService<
                Microsoft.Extensions.Options.IOptionsMonitor<OpenIdConnectOptions>>();
            var oidcOptions = oidcOptionsMonitor.Get(OpenIdConnectDefaults.AuthenticationScheme);

            if (oidcOptions.Configuration?.EndSessionEndpoint != null)
            {
                await context.SignOutAsync(OpenIdConnectDefaults.AuthenticationScheme, props);
            }

            await context.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme, props);
        });

        return group;
    }

    private static AuthenticationProperties GetAuthProperties(string? returnUrl)
    {
        // TODO: Use HttpContext.Request.PathBase instead.
        const string pathBase = "/";

        // Prevent open redirects.
        if (string.IsNullOrEmpty(returnUrl))
        {
            returnUrl = pathBase;
        }
        else if (!Uri.IsWellFormedUriString(returnUrl, UriKind.Relative))
        {
            returnUrl = new Uri(returnUrl, UriKind.Absolute).PathAndQuery;
        }
        else if (returnUrl[0] != '/')
        {
            returnUrl = $"{pathBase}{returnUrl}";
        }

        return new AuthenticationProperties { RedirectUri = returnUrl };
    }
}
```

### 5. Implement PersistingRevalidatingAuthenticationStateProvider (Server Project)

Trong Blazor Web App, bạn sẽ nhận được một `ClaimsPrincipal` thông qua `AuthenticationState` như 
đã nói ở trên. Nhưng để tách biệt logic UI với chi tiết xác thực, bạn nên ánh xạ 
`ClaimsPrincipal` sang model đơn giản hơn như `UserInfo`.

```csharp

public class UserInfo
{
    public string Sub { get; set; } = default!;
    public string? Email { get; set; }
    public string? Name { get; set; }
    public string? Picture { get; set; }

    public static UserInfo FromClaimsPrincipal(ClaimsPrincipal principal)
    {
        var subClaim = principal.FindFirst("sub") ?? principal.FindFirst(ClaimTypes.NameIdentifier)
                       ?? principal.FindFirst("http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier");

        if (subClaim == null)
        {
            throw new InvalidOperationException("Could not find required 'sub' claim.");
        }

        var email = principal.FindFirst(ClaimTypes.Email)?.Value
                    ?? principal.FindFirst("email")?.Value;

        var name = principal.FindFirst("name")?.Value
                   ?? principal.FindFirst(ClaimTypes.GivenName)?.Value
                   ?? principal.FindFirst(ClaimTypes.Surname)?.Value;

        var picture = principal.FindFirst("picture")?.Value;

        return new UserInfo
        {
            Sub = subClaim.Value,
            Email = email,
            Name = name,
            Picture = picture
        };
    }

    public ClaimsPrincipal ToClaimsPrincipal()
    {
        var claims = new List<Claim>();

        if (!string.IsNullOrEmpty(Sub))
            claims.Add(new Claim("sub", Sub));
        if (!string.IsNullOrEmpty(Email))
            claims.Add(new Claim(ClaimTypes.Email, Email));
        if (!string.IsNullOrEmpty(Name))
            claims.Add(new Claim(ClaimTypes.Name, Name));
        if (!string.IsNullOrEmpty(Picture))
            claims.Add(new Claim("picture", Picture));

        var identity = new ClaimsIdentity(claims, "oidc");
        return new ClaimsPrincipal(identity);
    }


    public static string? GetClaimFallback(ClaimsPrincipal principal, params string[] types)
    {
        foreach (var t in types)
        {
            var c = principal.FindFirst(t);
            if (c != null) return c.Value;
        }
        return null;
    }
}
```


```csharp
internal sealed class PersistingAuthenticationStateProvider
    : AuthenticationStateProvider, IHostEnvironmentAuthenticationStateProvider, IDisposable
{
    private readonly PersistentComponentState _persistentComponentState;
    private readonly PersistingComponentStateSubscription _subscription;
    private Task<AuthenticationState>? _authenticationStateTask;

    public PersistingAuthenticationStateProvider(PersistentComponentState state)
    {
        _persistentComponentState = state;
        _subscription = state.RegisterOnPersisting(OnPersistingAsync, RenderMode.InteractiveWebAssembly);
    }

    public override Task<AuthenticationState> GetAuthenticationStateAsync()
        => _authenticationStateTask ??
            throw new InvalidOperationException($"Do not call {nameof(GetAuthenticationStateAsync)} outside of the DI scope for a Razor component. Typically, this means you can call it only within a Razor component or inside another DI service that is resolved for a Razor component.");

    public void SetAuthenticationState(Task<AuthenticationState> task)
    {
        _authenticationStateTask = task;
    }

    private async Task OnPersistingAsync()
    {
        var authenticationState = await GetAuthenticationStateAsync();
        var principal = authenticationState.User;

        if (principal.Identity?.IsAuthenticated == true)
        {
            _persistentComponentState.PersistAsJson(nameof(UserInfo), UserInfo.FromClaimsPrincipal(principal));
        }
    }

    public void Dispose()
    {
        _subscription.Dispose();
    }
}
```

Microsoft cung cấp CookieOidcRefresher để tự động refresh cookie khi token sắp hết hạn. 
Nhờ đó, người dùng không bị logout khi cookie hết hạn.

```csharp
public class CookieOidcRefresher
{
    public CookieOidcRefresher(IOptionsMonitor<OpenIdConnectOptions> oidcOptionsMonitor)
    {
        _oidcOptionsMonitor = oidcOptionsMonitor;
    }

    private readonly OpenIdConnectProtocolValidator _oidcTokenValidator = new()
    {
        // We no longer have the original nonce cookie which is deleted at the end of the authorization code flow having served its purpose.
        // Even if we had the nonce, it's likely expired. It's not intended for refresh requests. Otherwise, we'd use oidcOptions.ProtocolValidator.
        RequireNonce = false,
    };
    private readonly IOptionsMonitor<OpenIdConnectOptions> _oidcOptionsMonitor;

    public async Task ValidateOrRefreshCookieAsync(CookieValidatePrincipalContext validateContext, string oidcScheme)
    {
        var accessTokenExpirationText = validateContext.Properties.GetTokenValue("expires_at");
        if (!DateTimeOffset.TryParse(accessTokenExpirationText, out var accessTokenExpiration))
        {
            return;
        }

        var oidcOptions = _oidcOptionsMonitor.Get(oidcScheme);
        var now = oidcOptions.TimeProvider!.GetUtcNow();
        if (now + TimeSpan.FromMinutes(5) < accessTokenExpiration)
        {
            return;
        }

        var oidcConfiguration = await oidcOptions.ConfigurationManager!.GetConfigurationAsync(validateContext.HttpContext.RequestAborted);
        var tokenEndpoint = oidcConfiguration.TokenEndpoint ?? throw new InvalidOperationException("Cannot refresh cookie. TokenEndpoint missing!");

        using var refreshResponse = await oidcOptions.Backchannel.PostAsync(tokenEndpoint,
            new FormUrlEncodedContent(new Dictionary<string, string?>()
            {
                ["grant_type"] = "refresh_token",
                ["client_id"] = oidcOptions.ClientId,
                ["client_secret"] = oidcOptions.ClientSecret,
                ["scope"] = string.Join(" ", oidcOptions.Scope),
                ["refresh_token"] = validateContext.Properties.GetTokenValue("refresh_token"),
            }));

        if (!refreshResponse.IsSuccessStatusCode)
        {
            validateContext.RejectPrincipal();
            return;
        }

        var refreshJson = await refreshResponse.Content.ReadAsStringAsync();
        var message = new OpenIdConnectMessage(refreshJson);

        var validationParameters = oidcOptions.TokenValidationParameters.Clone();
        if (oidcOptions.ConfigurationManager is BaseConfigurationManager baseConfigurationManager)
        {
            validationParameters.ConfigurationManager = baseConfigurationManager;
        }
        else
        {
            validationParameters.ValidIssuer = oidcConfiguration.Issuer;
            validationParameters.IssuerSigningKeys = oidcConfiguration.SigningKeys;
        }

        var validationResult = await oidcOptions.TokenHandler.ValidateTokenAsync(message.IdToken, validationParameters);

        if (!validationResult.IsValid)
        {
            validateContext.RejectPrincipal();
            return;
        }

        var validatedIdToken = JwtSecurityTokenConverter.Convert(validationResult.SecurityToken as JsonWebToken);
        validatedIdToken.Payload["nonce"] = null;
        _oidcTokenValidator.ValidateTokenResponse(new()
        {
            ProtocolMessage = message,
            ClientId = oidcOptions.ClientId,
            ValidatedIdToken = validatedIdToken,
        });

        validateContext.ShouldRenew = true;
        validateContext.ReplacePrincipal(new ClaimsPrincipal(validationResult.ClaimsIdentity));

        var expiresIn = int.Parse(message.ExpiresIn, NumberStyles.Integer, CultureInfo.InvariantCulture);
        var expiresAt = now + TimeSpan.FromSeconds(expiresIn);
        validateContext.Properties.StoreTokens([
            new() { Name = "access_token", Value = message.AccessToken },
            new() { Name = "id_token", Value = message.IdToken },
            new() { Name = "refresh_token", Value = message.RefreshToken },
            new() { Name = "token_type", Value = message.TokenType },
            new() { Name = "expires_at", Value = expiresAt.ToString("o", CultureInfo.InvariantCulture) },
        ]);
    }
}
```

```csharp
internal static class CookieOidcServiceCollectionExtensions
{
    public static IServiceCollection ConfigureCookieOidcRefresh(this IServiceCollection services, string cookieScheme, string oidcScheme)
    {
        services.AddSingleton<CookieOidcRefresher>();
        services.AddOptions<CookieAuthenticationOptions>(cookieScheme).Configure<CookieOidcRefresher>((cookieOptions, refresher) =>
        {
            cookieOptions.Events.OnValidatePrincipal = context => refresher.ValidateOrRefreshCookieAsync(context, oidcScheme);
        });
        
        services.AddOptions<OpenIdConnectOptions>(oidcScheme).Configure(oidcOptions =>
        {
            var provider = oidcOptions.Authority ?? "";

            // Chỉ thêm offline_access nếu không phải Google
            if (!provider.Contains("accounts.google.com", StringComparison.OrdinalIgnoreCase))
            {
                oidcOptions.Scope.Add(OpenIdConnectScope.OfflineAccess);
            }

            oidcOptions.SaveTokens = true;
        });

        return services;
    }
}
```

### 3. Cấu hình appsettings.json (Server Project)

Ví dụ với Google:
```javascript
{
  "Oidc": {
    "Authority": "https://accounts.google.com",
    "ClientId": "YOUR_GOOGLE_CLIENT_ID",
    "ClientSecret": "YOUR_GOOGLE_CLIENT_SECRET",
    "CallbackPath": "/signin-oidc",
    "SignedOutCallbackPath": "/signout-callback-oidc",
    "ResponseType": "code"
  }
}
```

> Lưu client secret trong enviroment variables, không lưu trong appsettings.json (sử dụng user-secrets nếu là môi trường development).

### 4. Cấu hình Program.cs (Client Project)


```csharp
var builder = WebAssemblyHostBuilder.CreateDefault(args);

builder.Services.AddAuthorizationCore();
builder.Services.AddScoped<AuthenticationStateProvider, PersistentAuthenticationStateProvider>();

await builder.Build().RunAsync();
```


```csharp
internal sealed class PersistentAuthenticationStateProvider : AuthenticationStateProvider
{
    private static readonly Task<AuthenticationState> _defaultUnauthenticatedTask =
        Task.FromResult(new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity())));

    private readonly Task<AuthenticationState> _authenticationStateTask = _defaultUnauthenticatedTask;

    public PersistentAuthenticationStateProvider(PersistentComponentState state)
    {
        if (!state.TryTakeFromJson<UserInfo>(nameof(UserInfo), out var userInfo) || userInfo is null)
        {
            return;
        }

        _authenticationStateTask = Task.FromResult(new AuthenticationState(userInfo.ToClaimsPrincipal()));
    }

    public override Task<AuthenticationState> GetAuthenticationStateAsync() => _authenticationStateTask;
}
```

### 5. Cấu hình Routes.razor

```markup
<CascadingAuthenticationState>
    <Router AppAssembly="@typeof(Blogtify.Client.Program).Assembly">
        <Found Context="routeData">
            <AuthorizeRouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)">
                <NotAuthorized>
                    <p>Bạn cần đăng nhập để truy cập trang này.</p>
                </NotAuthorized>
            </AuthorizeRouteView>
        </Found>
        <NotFound>
            <PageTitle>Not found</PageTitle>
            <LayoutView Layout="@typeof(MainLayout)">
                <p role="alert">Sorry, there's nothing at this address.</p>
            </LayoutView>
        </NotFound>
    </Router>
</CascadingAuthenticationState>
```

### 6. Cấu hình Login/Logout

Sử dụng endpoint server để trigger flow:
```markup
@inject NavigationManager NavigationManager

<AuthorizeView>
    <Authorized>
        <span>Xin chào, @context.User.Identity?.Name!</span>
        <form action="authentication/logout" method="post">
            <AntiforgeryToken />
            <input type="hidden" name="returnUrl" value="@NavigationManager.Uri" />
            <button type="submit">Đăng xuất</button>
        </form>
    </Authorized>
    <NotAuthorized>
        <a href="authentication/login?returnUrl=@Uri.EscapeDataString(NavigationManager.Uri)">Đăng nhập</a>
    </NotAuthorized>
</AuthorizeView>
```

### 7. Gọi API Protected trong mô hình BFF

#### Hai loại API protected

Trong mô hình BFF, ta gặp hai loại API chính:
- Internal API: API nằm trong cùng server. Xác thực bằng cookie.
- API nằm ở dịch vụ khác (GitHub, Keycloak...). Gọi bằng access token.

#### Internal API

**Cách hoạt động:**
- Người dùng đã đăng nhập, lúc này cookie xác thực lưu trong trình duyệt.
- Blazor client gọi endpoint /api/.... nằm trên server.
- Server đọc cookie, xác định người dùng từ `HttpContext.User` mà không cần token.

```csharp
app.MapGet("/api/profile", (HttpContext ctx) =>
{
    var user = ctx.User;
    if (user?.Identity?.IsAuthenticated != true)
        return Results.Unauthorized();

    return Results.Ok(new
    {
        Name = user.Identity!.Name,
        Email = user.FindFirst(ClaimTypes.Email)?.Value
    });
}).RequireAuthorization();
```

Client gọi:
```csharp
@inject HttpClient Http

@code {
    private object? profile;

    protected override async Task OnInitializedAsync()
    {
        // Cookie tự động gửi kèm
        profile = await Http.GetFromJsonAsync<object>("api/profile");
    }
}
```

#### External API

**Cách hoạt động:**
- Server BFF lưu access token sau khi user đăng nhập OIDC (SaveTokens = true).
- Khi client gọi API nội bộ (ví dụ /api/github-repos), server sẽ:
    - Lấy access token từ cookie bảo mật (`GetTokenAsync("access_token")`).
    - Đính token vào header Authorization: Bearer ...
    - Gọi API ngoài thay mặt client.
- Client vẫn chỉ dùng cookie do đó không cần lưu token ở trình duyệt.


Trong `TokenHandler` (`DelegatingHandler`) bạn lấy token 
từ `HttpContext.GetTokenAsync("access_token")` rồi thêm vào header. 

```csharp
using System.Net.Http.Headers;
using Microsoft.AspNetCore.Authentication;

public class TokenHandler(IHttpContextAccessor httpContextAccessor) : 
    DelegatingHandler
{
    protected override async Task<HttpResponseMessage> SendAsync(
        HttpRequestMessage request, CancellationToken cancellationToken)
    {
        if (httpContextAccessor.HttpContext is null)
        {
            throw new Exception("HttpContext not available");
        }

        var accessToken = await httpContextAccessor.HttpContext.GetTokenAsync("access_token");

        if (accessToken is null)
        {
            throw new Exception("No access token");
        }

        request.Headers.Authorization =
            new AuthenticationHeaderValue("Bearer", accessToken);

        return await base.SendAsync(request, cancellationToken);
    }
}
```

Cấu hình trong `Program.cs`:
```csharp
builder.Services.AddHttpContextAccessor();
builder.Services.AddTransient<TokenHandler>();

builder.Services.AddHttpClient("ExternalApi", client =>
{
    client.BaseAddress = new Uri("https://api.github.com/");
    client.DefaultRequestHeaders.UserAgent.ParseAdd("BlazorBFF");
}).AddHttpMessageHandler<TokenHandler>();
```

**Endpoint proxy server:**
```csharp
app.MapGet("/api/github-repos", async (IHttpClientFactory factory) =>
{
    var client = factory.CreateClient("ExternalApi");
    var repos = await client.GetFromJsonAsync<List<GithubRepo>>("user/repos");
    return Results.Ok(repos);
}).RequireAuthorization();
```

**Client gọi tới server endpoint:**

```markup
@inject HttpClient Http

@code {
    private List<GithubRepo>? repos;

    protected override async Task OnInitializedAsync()
    {
        repos = await Http.GetFromJsonAsync<List<GithubRepo>>("api/github-repos");
    }
}
```

Client không cần biết gì về access token, nó chỉ đơn giản là gửi request tới server.

> Trong phần cấu hình OIDC, bật `SaveTokens = true` để lưu token vào cookie mã hóa.

# Authorization trong Blazor

## Authorization trong khi Prerendering

Với BFF, prerendering sử dụng `HttpContext.User` lấy từ cookie nên `<AuthorizeView>` hiển 
thị đúng ngay từ đầu. Với Non-BFF, trạng thái ban đầu là unauthorized cho đến khi client hydrate. 

## Role-based Authorization

Phân quyền dựa trên **Role** là cách phổ biến nhất, sử dụng khi 
Identity Provider (Azure AD, IdentityServer, Keycloak...) trả về claim `role` hoặc `roles`.

Sử dụng `AuthorizeView`:
```markup
<AuthorizeView Roles="Administrator">
    <Authorized>
        <h3>Khu vực quản trị</h3>
        <p>Chỉ quản trị viên mới thấy được phần này.</p>
    </Authorized>
    <NotAuthorized>
        <p>Bạn không có quyền truy cập.</p>
    </NotAuthorized>
</AuthorizeView>
```

Hoặc route được bảo vệ bằng attribute:
```markup
@attribute [Authorize(Roles = "Administrator")]
<h3>Admin Dashboard</h3>
```

> 💡 Trong BFF mode, role của user được server đưa vào Claims trong cookie vì vậy 
vẫn hoạt động bình thường ở cả prerender.

## Policy-based Authorization

Policy-based cho phép bạn định nghĩa quy tắc phức tạp hơn Role.

Định nghĩa Policy trong `Program.cs`:
```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("VerifiedEmail", policy =>
        policy.RequireClaim("email_verified", "true"));

    options.AddPolicy("EmployeeOnly", policy =>
        policy.RequireClaim("department", "IT", "HR"));
});
```

Sử dụng `AuthorizeView`:
```markup
<AuthorizeView Policy="EmployeeOnly">
    <Authorized>
        <p>Chào nhân viên phòng IT hoặc HR!</p>
    </Authorized>
    <NotAuthorized>
        <p>Bạn không có quyền truy cập nội dung này.</p>
    </NotAuthorized>
</AuthorizeView>
```

Hoặc route được bảo vệ bằng attribute:
```markup
@attribute [Authorize(Policy = "VerifiedEmail")]
```

> Với BFF, mọi claim đều đến từ cookie do server cấp nên Policy hoạt động ngay cả 
trong giai đoạn prerendering.

## Resource-based Authorization

Resource-based cho phép kiểm tra quyền động (dynamic), tùy vào từng đối tượng cụ thể. 
Ví dụ: User chỉ được sửa bài viết của chính mình hoặc xóa tài nguyên mà họ sở hữu.

Tạo Handler Resource:
```csharp
using Microsoft.AspNetCore.Authorization;

public class Document
{
    public string OwnerId { get; set; } = default!;
}

public class DocumentAuthorizationHandler : AuthorizationHandler<OperationAuthorizationRequirement, Document>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        OperationAuthorizationRequirement requirement,
        Document resource)
    {
        if (requirement.Name == "Edit" && 
            context.User.Identity?.Name == resource.OwnerId)
        {
            context.Succeed(requirement);
        }
        return Task.CompletedTask;
    }
}
```

Đăng ký handler trong `Program.cs`:
```csharp
builder.Services.AddSingleton<IAuthorizationHandler, DocumentAuthorizationHandler>();
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("CanEdit", policy =>
        policy.AddRequirements(new OperationAuthorizationRequirement { Name = "Edit" }));
});
```

Dùng trong Component
```markup
@page "/document/{Id}"
@inject IAuthorizationService AuthorizationService
@inject AuthenticationStateProvider AuthProvider

@if (canEdit)
{
    <button>Sửa tài liệu</button>
}
else
{
    <p>Bạn không có quyền chỉnh sửa tài liệu này.</p>
}

@code {
    Document doc = new() { OwnerId = "alice@example.com" };

    bool canEdit = false;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        var result = await AuthorizationService.AuthorizeAsync(user, doc, "CanEdit");
        canEdit = result.Succeeded;
    }
}
```

> Xem thêm phần Authorization [tại đây](/post/authentication-va-authorization-trong-net#claims-based-authorization)

# Kết luận

Authentication và Authorization trong Blazor Web App phức tạp 
do prerender và render modes, nhưng BFF là cách an toàn và hiệu quả nhất. 
Hy vọng bài viết giúp bạn:
- Hiểu luồng OIDC với BFF.
- Xử lý authentication trong prerender.
- Triển khai các loại authorization.
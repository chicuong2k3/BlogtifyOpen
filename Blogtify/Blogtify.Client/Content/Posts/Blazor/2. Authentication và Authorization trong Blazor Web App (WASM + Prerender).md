---
url: [/post/authentication-va-authorization-trong-blazor-web-app-wasm]
title: "Authentication và Authorization trong Blazor Web App (WASM + Prerender)"
$attribute: PostMetadata(Id = 2, Title = "Authentication và Authorization trong Blazor Web App (WASM + Prerender)", Category = "Blazor", LastModified = "20-10-2025")
$layout: BlogContentLayout
---

Blazor Web App từ **.NET 8** mang đến một mô hình kết hợp mới giữa 
**Server-Side Rendering (SSR)** và **WebAssembly (WASM)**: **WASM Render Mode với 
Prerendering** kết hợp tốc độ tải nhanh, SEO tốt và trải nghiệm tương tác mượt mà 
trên client. Cơ chế này cho phép ứng dụng **render lần đầu ở server**, sau đó 
**kích hoạt chế độ tương tác (interactive)** trên client bằng WebAssembly. 
Nhưng điều này dẫn đến một câu hỏi quan trọng là: 
*Khi prerender ở server, làm sao Authentication hoạt động khi client chưa chạy?* 

Bài viết này sẽ giải thích chi tiết cách **Authentication và Authorization hoạt động 
trong Blazor Web App (WASM + Prerender)**. 

> 📘 Nếu bạn muốn hiểu nền tảng về `Authentication` và `Authorization` trong ASP.NET Core, 
hãy xem lại bài viết [Authentication và Authorization trong .NET](/post/authentication-va-authorization-trong-net)

# Tổng quan về Authentication trong Blazor Web App

Blazor không khuyến khích bạn tự xây dựng cơ chế đăng nhập (username/password) 
hay quản lý token thủ công.  
Thay vào đó, framework này hỗ trợ **OpenID Connect (OIDC)** - chuẩn xác thực hiện đại, 
an toàn và tương thích với các **Identity Provider (IdP)** như:
- **Azure Active Directory (Microsoft Entra ID)**
- **Auth0**
- **Keycloak**
- **Google Identity**
- Hoặc bất kỳ IdP nào hỗ trợ chuẩn **OIDC + PKCE**

# Biểu diễn User trong Blazor

Trong Blazor, người dùng được biểu diễn bằng **Claims-Based Identity**. Đây là một 
mô hình bảo mật linh hoạt, mô tả user qua các **Claims** (mảnh thông tin như 
Email, Role, Permission...)

> 💡 Nếu bạn muốn hiểu sâu hơn về `ClaimsPrincipal`, `ClaimsIdentity` và cách mà .NET 
xây dựng danh tính người dùng hãy đọc [tại đây](/post/authentication-va-authorization-trong-net#kien-truc-authentication-va-authorization-trong.net)

Blazor sử dụng `AuthenticationState` để lấy thông tin người dùng hiện tại. 
Khi người dùng đã đăng nhập, `ClaimsPrincipal` trong `AuthenticationState` chứa các 
thông tin (claims) của người dùng.

```markup
@page "/me"
@inject AuthenticationStateProvider AuthStateProvider

<h3>Thông tin người dùng</h3>

@code {
    private string? userName;
    private string? email;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity?.IsAuthenticated == true)
        {
            userName = user.Identity.Name;
            email = user.FindFirst(c => c.Type == "email")?.Value;
        }
    }
}
```


# Cấu trúc Render Mode trong Blazor Web App

Từ .NET 8, Blazor Web App có 3 chế độ render chính:
- **Server render mode:** Chạy hoàn toàn ở server thông qua SignalR.
- **Auto render mode:** Bắt đầu ở server, sau đó chuyển sang client (hybrid).
- **WASM render mode:** Chạy hoàn toàn bằng WebAssembly nhưng có thể prerender HTML ở server 
để cải thiện SEO và tốc độ hiển thị ban đầu.

Với **WASM + Prerender** thì ứng dụng hoạt động theo luồng sau:

<div class="mermaid">
flowchart LR
    A[User truy cập app] --> B[Server prerender HTML]
    B --> C[Trả về HTML tĩnh cho Browser]
    C --> D[Browser tải WASM + .dll]
    D --> E[Client-side khởi động Blazor]
    E --> F[Xác thực với OIDC provider (PKCE Flow)]
    F --> G[Tải lại claims và render UI]
</div>

# Vì sao không dùng Cookie Authentication?

Blazor WebAssembly không có `HttpContext`, không có pipeline `UseAuthentication()` 
hay `UseAuthorization()` vì mọi thứ chạy trong trình duyệt. 

Điều này có nghĩa là:
- Không thể dùng cookie (`.AspNetCore.Cookies`) để lưu trạng thái đăng nhập.  
- Không lưu trạng thái session trên server.
- Phải xác thực **qua OpenID Connect (OIDC) Authorization Code Flow with PKCE** trực tiếp 
từ trình duyệt. 

> 💡 PKCE (Proof Key for Code Exchange) là phần mở rộng của OAuth2 giúp bảo vệ 
Authorization Code Flow khỏi tấn công man-in-the-middle. Đây là flow được khuyến nghị cho SPA. 

# Cấu hình Authentication với OIDC + PKCE

Cài đặt package:
```bash
dotnet add package Microsoft.AspNetCore.Components.WebAssembly.Authentication

```

Cấu hình `Program.cs` (Client Project):
```csharp
using Microsoft.AspNetCore.Components.WebAssembly.Authentication;

var builder = WebAssemblyHostBuilder.CreateDefault(args);
builder.RootComponents.Add<App>("#app");

// Cấu hình OIDC
builder.Services.AddOidcAuthentication(options =>
{
    builder.Configuration.Bind("Oidc", options.ProviderOptions);
});

// Authorization cho client
builder.Services.AddAuthorizationCore(options =>
{
    options.AddPolicy("TeaLoversOnly", policy =>
        policy.RequireClaim("FavoriteDrink", "Tea"));
});

await builder.Build().RunAsync();
```

Cấu hình `wwwroot/appsettings.json`:
```javascript
{
  "Oidc": {
    "Authority": "https://login.microsoftonline.com/{tenantId}/v2.0",
    "ClientId": "your-client-id",
    "DefaultScopes": [
      "openid",
      "profile",
      "email",
      "api://your-api-id/access_as_user"
    ],
    "ResponseType": "code"
  }
}
```

> ⚠️ Blazor lưu token trong sessionStorage (mặc định). 
Chỉ dùng localStorage nếu bạn hiểu rõ XSS vì token trong localStorage dễ bị đánh cắp hơn. 
Không bao giờ lưu refresh token trên client.

# Authentication trong quá trình Prerender

Đây là điểm quan trọng nhất khi làm Blazor Web App ở WASM render mode. 
Khi prerender:
- HTML render từ server trước khi WASM tải.
- Không có `AuthenticationState` vì browser chưa chạy script và chưa có token 
do đó `AuthenticationState.User.Identity.IsAuthenticated == false`.

Sau khi WASM tải:
- Token được khôi phục từ storage.
- `AuthenticationStateProvider` cập nhật lại User.
- Toàn bộ component <AuthorizeView> được render lại với thông tin đúng.

Kết quả là nếu bạn render các phần tử phụ thuộc vào login (`AuthorizeView`, `UserInfo`),
chúng sẽ tạm thời hiển thị Anonymous trong lúc prerender.

# Cách xử lý Authentication trong khi prerender

Có 2 cách xử lý:

1. Dùng `<AuthorizeView>` với fallback rõ ràng:
```markup
<AuthorizeView>
    <Authorized>
        <p>Chào mừng, @context.User.Identity.Name!</p>
    </Authorized>
    <Authorizing>
        <p>Đang kiểm tra trạng thái đăng nhập...</p>
    </Authorizing>
    <NotAuthorized>
        <p>Bạn chưa đăng nhập.</p>
    </NotAuthorized>
</AuthorizeView>
```

Trong giai đoạn prerender, trạng thái là Authorizing. 
Khi WASM khởi chạy và token được load, UI sẽ render lại tự động.

2. Tắt prerender nếu không cần để giảm flash UI

Nếu app của bạn thuần client-side, không cần SEO, có thể tắt prerender:
```csharp
app.MapRazorComponents<App>()
   .AddInteractiveWebAssemblyRenderMode(options => options.Prerender = false);
```

Khi đó, server chỉ trả <app></app> và toàn bộ UI render khi WASM khởi động.

# Gọi API protected từ Blazor WASM

## Cách 1: Dùng AuthorizationMessageHandler (Khuyến nghị)

```csharp
builder.Services.AddHttpClient("WeatherApi",
    client => client.BaseAddress = new Uri("https://api.yourdomain.com"))
    .AddHttpMessageHandler(sp =>
        sp.GetRequiredService<AuthorizationMessageHandler>()
          .ConfigureHandler(
              authorizedUrls: new[] { "https://api.yourdomain.com" },
              scopes: new[] { "api://your-api-id/access_as_user" }));
```

Sử dụng trong component:
```markup
@inject IHttpClientFactory ClientFactory

@code {
    private WeatherForecast[]? forecasts;

    protected override async Task OnInitializedAsync()
    {
        var client = ClientFactory.CreateClient("WeatherApi");
        forecasts = await client.GetFromJsonAsync<WeatherForecast[]>("/weather");
    }
}
```

## Cách 2: Dùng IAccessTokenProvider (thủ công)

```markup
@inject IAccessTokenProvider TokenProvider
@inject HttpClient Http

@code {
    protected override async Task OnInitializedAsync()
    {
        var tokenResult = await TokenProvider.RequestAccessToken();
        if (tokenResult.TryGetToken(out var token))
        {
            Http.DefaultRequestHeaders.Authorization =
                new AuthenticationHeaderValue("Bearer", token.Value);
        }
    }
}
```

> 🔒 Token được quản lý và refresh tự động khi còn hợp lệ. 
Bạn có thể cấu hình thêm `offline_access` để lấy refresh token nếu IdP hỗ trợ.

# Login với Google/Facebook

OIDC cho phép tích hợp dễ dàng các nhà cung cấp OAuth2 như Google, Facebook. 

## Google

Google hỗ trợ OIDC chuẩn nên có thể dùng trực tiếp với `AddOidcAuthentication`.

```javascript
{
  "Oidc": {
    "Authority": "https://accounts.google.com",
    "ClientId": "your-google-client-id",
    "DefaultScopes": [ "openid", "profile", "email" ],
    "ResponseType": "code"
  }
}
```

> ⚠️ Với Google, bạn cần bật Authorized redirect URIs trỏ về 
https://yourdomain.com/authentication/login-callback 
trong Google Cloud Console.

## Facebook (OAuth2 — Không hỗ trợ OIDC chuẩn)

Facebook chỉ hỗ trợ OAuth2, không cung cấp ID token vì vậy không thể dùng 
trực tiếp với `AddOidcAuthentication`.

Giải pháp là dùng BFF pattern để xác thực qua server rồi gửi claims về client 
hoặc dùng nhà cung cấp trung gian (Auth0, Azure AD B2C) để liên kết Facebook thành một 
OIDC provider hợp lệ.

> ⚠️ Không bao giờ trao đổi trực tiếp OAuth code của Facebook từ WASM. 
Bạn sẽ phải xử lý `client_secret` và nó không được phép lưu trong browser.

# Authorization trong Blazor

Sau khi xác thực, `ClaimsPrincipal` trong `AuthenticationState` được sử dụng để phân quyền. 

## Role-based Authorization

```markup
<AuthorizeView Roles="Admin">
    <h3>Chào mừng, Admin!</h3>
    <p>Bạn có quyền truy cập quản trị.</p>
</AuthorizeView>
```

## Claims-based Authorization

```markup
<AuthorizeView Policy="TeaLoversOnly">
    <h3>Xin chào tín đồ trà!</h3>
</AuthorizeView>
```

Đăng ký policy trong `Program.cs`:
```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("TeaLoversOnly", policy =>
        policy.RequireClaim("FavoriteDrink", "Tea"));
});
```

> Xem thêm phần Claims-based Authorization và Policy-based Authorization 
[tại đây](/post/authentication-va-authorization-trong-net#claims-based-authorization)

# Kết luận

Blazor Web App (WASM + Prerender) kết hợp được tốc độ của SSR và linh hoạt của SPA, 
nhưng yêu cầu hiểu rõ OIDC client flow và trạng thái Authentication khi prerender. 
Nếu bạn làm đúng cấu hình, toàn bộ quá trình đăng nhập từ prerender đến WASM sẽ 
diễn ra tự động và an toàn. 
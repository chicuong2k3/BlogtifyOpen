---
url: [/post/authentication-va-authorization-trong-blazor]
title: "Authentication và Authorization trong Blazor"
$attribute: PostMetadata(Id = 2, Title = "Authentication và Authorization trong Blazor", Category = "Blazor", LastModified = "21-10-2025")
$layout: BlogContentLayout
---

Từ .NET 8 trở đi, Microsoft hợp nhất hai mô hình Server và Blazor WebAssembly thành 
Blazor Web App, cho phép Prerender trên server để cải thiện SEO và tốc độ tải trang. 
Tuy nhiên, điều này làm cho việc xử lý Authentication trở nên phức tạp hơn vì trạng 
thái đăng nhập ban đầu được render ở server (nơi chưa có token), nhưng sau đó cần 
đồng bộ với client khi interactive render mode được kích hoạt.

Bài viết này sẽ hướng dẫn chi tiết cách triển khai **Authentication** và **Authorization** 
trong **Blazor Web App**, giải thích các vấn đề khi đồng bộ trạng thái đăng nhập giữa 
server và client và hướng dẫn triển khai mô hình **BFF (Backend for Frontend)** — mô hình
được Microsoft khuyến nghị sử dụng.

> 📘 Nếu bạn chưa quen với `Authentication` và `Authorization` trong .NET, 
hãy xem lại bài viết [Authentication và Authorization trong .NET](/post/authentication-va-authorization-trong-net)

# Tổng quan về Authentication trong Blazor Web App

## Claims-based Identity

Blazor (và toàn bộ ASP.NET Core) dựa trên mô hình **Claims-based Identity** — 
mỗi người dùng được biểu diễn bởi một `ClaimsPrincipal` chứa các `Claim`.

> 💡 Để hiểu rõ hơn về mô hình Claims-based Identity trong .NET hãy 
đọc [bài viết này](/post/authentication-va-authorization-trong-net#kien-truc-authentication-va-authorization-trong.net)

Các claim này được lưu trong `ClaimsPrincipal` và có thể truy cập thông 
qua `AuthenticationStateProvider`.

```markup
@page "/me"
@inject AuthenticationStateProvider AuthStateProvider

<h3>Thông tin người dùng</h3>

@code {
    private string? userName;
    private string? email;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity?.IsAuthenticated == true)
        {
            userName = user.Identity.Name;
            email = user.FindFirst(c => c.Type == "email")?.Value;
        }
    }
}
```

Hoặc đơn giản hơn là dùng Cascading Parameter:
```markup
@code {
    [CascadingParameter] 
    private Task<AuthenticationState>? authenticationState { get; set; }

    private async Task DoSomething()
    {
        var authState = await authenticationState;
        var user = authState?.User;
        if (user?.Identity?.IsAuthenticated == true)
        {
            // Xử lý logic
        }
    }
}
```

## Render Mode và Authentication

Blazor Web App hỗ trợ nhiều render mode: Static SSR, Interactive Server, 
Interactive WebAssembly và Interactive Auto. Mỗi mode xử lý authentication khác nhau:

| Render Mode | Mô tả | Cơ chế Authentication |
|--------------|--------|------------------------|
| **Static SSR** | UI được render tĩnh trên server. | Sử dụng HttpContext.User (cookie-based), xử lý bởi ASP.NET Core pipeline. Không render nếu unauthorized. |
| **Server** | UI được render và xử lý sự kiện trên server qua **SignalR**. | Authentication qua circuit SignalR; trạng thái duy trì trong circuit lifetime, với revalidation định kỳ. |
| **WebAssembly (WASM)** | Ứng dụng chạy hoàn toàn trên trình duyệt. | Trạng thái được deserialize từ server; client không enforce bảo mật tuyệt đối. |
| **Auto** | Bắt đầu với Server/SSR, chuyển sang WASM khi client tải xong. | Kết hợp cả hai; cần bảo mật cả component attribute và API endpoints. |


Sự khác biệt giữa prerender và hydration:
- Prerender: chạy hoàn toàn trên server, có thể lấy HttpContext.User.
- Hydration: khi client tải runtime WASM và đồng bộ state. 
Lúc này Blazor cần cơ chế serialize AuthenticationState từ server sang client.

.NET cung cấp 2 provider tương ứng:
- Server: `PersistingAuthenticationStateProvider`.
- Client: `PersistentAuthenticationStateProvider`.

Hai provider này kết hợp để persist `AuthenticationState` từ server qua client
thông qua `PersistentComponentState`.

# Authentication không dùng BFF (Non-BFF) - Không khuyến nghị cho Blazor Web App

Non-BFF (client-side OIDC với PKCE) chỉ phù hợp cho standalone Blazor WASM 
(không có server host). Trong Blazor Web App, nó gây xung đột với prerender 
và kém bảo mật (token lưu ở browser, dễ bị attack như XSS).

Microsoft không khuyến nghị cho production nên chỉ dùng nếu app thuần 
client-side và chấp nhận rủi ro. Với Facebook, cần provider trung gian vì 
không hỗ trợ OIDC đầy đủ.

Nếu vẫn muốn dùng, cấu hình OIDC ở client (AddOidcAuthentication), 
nhưng tắt prerender để tránh lỗi. Chi tiết xem docs Microsoft, nhưng bài viết 
này ưu tiên BFF.

# Authentication với BFF (Khuyến nghị)

Backend for Frontend (BFF) là pattern khuyến nghị cho Blazor Web App, 
nơi server xử lý toàn bộ OIDC flow, lưu token an toàn, và client chỉ dùng 
cookie HttpOnly. Điều này đảm bảo bảo mật cao (token không lộ trên browser), 
tương thích prerender, và hoạt động với tất cả render mode.

## Luồng hoạt động

<div class="mermaid">
sequenceDiagram
    participant U as User
    participant B as Browser (Blazor Client)
    participant S as Server (BFF Host)
    participant IDP as Identity Provider
    participant API as Protected API
    U->>B: Truy cập ứng dụng
    B->>S: Gửi request (prerender)
    S->>IDP: Redirect đến IDP nếu unauthorized
    IDP->>U: Form đăng nhập
    U->>IDP: Nhập thông tin xác thực
    IDP-->>S: Trả Authorization Code
    S->>IDP: Gửi Code + Client Secret lấy Token
    IDP-->>S: Trả Access/ID/Refresh Token
    S-->>B: Set Cookie HttpOnly
    B->>S: Request tiếp theo kèm Cookie
    S->>API: Gọi API thay mặt user bằng Bearer token
</div>

- Token (access/refresh) chỉ tồn tại ở server.
- Client gọi API nội bộ qua server (BFF proxy), tránh lộ token.
- Prerender có thể đọc `HttpContext.User` ngay nên có thể render chính xác.

## Triển khai

### 1. Cài đặt package (Server Project)

```bash
dotnet add package Microsoft.AspNetCore.Authentication.OpenIdConnect
dotnet add package Microsoft.AspNetCore.Authentication.Cookies
```

### 2. Cấu hình Program.cs (Server Project)

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorComponents()
    .AddInteractiveWebAssemblyComponents();

builder.Services.AddScoped<AuthenticationStateProvider, PersistingAuthenticationStateProvider>();
builder.Services.AddCascadingAuthenticationState();
builder.Services.AddAuthorization();

JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();
builder.Services.AddAuthentication(options =>
{
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme;
})
.AddCookie(options =>
{
    options.Cookie.HttpOnly = true;
    options.Cookie.SameSite = SameSiteMode.Strict;
    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
})
.AddOpenIdConnect(options =>
{
    builder.Configuration.Bind("Oidc", options);
    options.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.SaveTokens = true; // Lưu token ở server để gọi API
    options.GetClaimsFromUserInfoEndpoint = true;
    options.Scope.Add("openid");
    options.Scope.Add("profile");
    options.Scope.Add("email");

    options.ClaimActions.MapJsonKey("sub", "sub");
    options.ClaimActions.MapUniqueJsonKey(ClaimTypes.NameIdentifier, "sub");
    options.ClaimActions.MapUniqueJsonKey(ClaimTypes.Email, "email");
    options.ClaimActions.MapUniqueJsonKey("picture", "picture");

    options.TokenValidationParameters.NameClaimType = ClaimTypes.Email;
});

builder.Services.ConfigureCookieOidcRefresh(
    CookieAuthenticationDefaults.AuthenticationScheme,
    OpenIdConnectDefaults.AuthenticationScheme);

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseWebAssemblyDebugging();
}

app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseAntiforgery();

app.UseAuthentication();
app.UseAuthorization();

app.MapRazorComponents<App>()
    .AddInteractiveWebAssemblyRenderMode()
    .AddAdditionalAssemblies(typeof(Blogtify.Client._Imports).Assembly);


app.MapLoginAndLogout();
app.Run();
```


```csharp
internal static class LoginLogoutEndpointRouteBuilderExtensions
{
    internal static IEndpointConventionBuilder MapLoginAndLogout(this IEndpointRouteBuilder endpoints)
    {
        var group = endpoints.MapGroup("authentication");

        group.MapGet("/login", (string? returnUrl) => TypedResults.Challenge(GetAuthProperties(returnUrl)))
            .AllowAnonymous();

        group.MapPost("/logout", async (HttpContext context, [FromQuery] string? returnUrl) =>
        {
            var props = GetAuthProperties(returnUrl);

            var oidcOptionsMonitor = context.RequestServices.GetRequiredService<
                Microsoft.Extensions.Options.IOptionsMonitor<OpenIdConnectOptions>>();
            var oidcOptions = oidcOptionsMonitor.Get(OpenIdConnectDefaults.AuthenticationScheme);

            if (oidcOptions.Configuration?.EndSessionEndpoint != null)
            {
                await context.SignOutAsync(OpenIdConnectDefaults.AuthenticationScheme, props);
            }

            await context.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme, props);
        });

        return group;
    }

    private static AuthenticationProperties GetAuthProperties(string? returnUrl)
    {
        // TODO: Use HttpContext.Request.PathBase instead.
        const string pathBase = "/";

        // Prevent open redirects.
        if (string.IsNullOrEmpty(returnUrl))
        {
            returnUrl = pathBase;
        }
        else if (!Uri.IsWellFormedUriString(returnUrl, UriKind.Relative))
        {
            returnUrl = new Uri(returnUrl, UriKind.Absolute).PathAndQuery;
        }
        else if (returnUrl[0] != '/')
        {
            returnUrl = $"{pathBase}{returnUrl}";
        }

        return new AuthenticationProperties { RedirectUri = returnUrl };
    }
}
```

Trong Blazor Web App, bạn sẽ nhận được một `ClaimsPrincipal` thông qua `AuthenticationState` như 
đã nói ở trên. Nhưng để tách biệt logic UI với chi tiết xác thực, bạn nên ánh xạ 
`ClaimsPrincipal` sang model đơn giản hơn như `UserInfo`.

```csharp

public class UserInfo
{
    public string Sub { get; set; } = default!;
    public string? Email { get; set; }
    public string? Name { get; set; }
    public string? Picture { get; set; }

    public static UserInfo FromClaimsPrincipal(ClaimsPrincipal principal)
    {
        var subClaim = principal.FindFirst("sub") ?? principal.FindFirst(ClaimTypes.NameIdentifier)
                       ?? principal.FindFirst("http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier");

        if (subClaim == null)
        {
            throw new InvalidOperationException("Could not find required 'sub' claim.");
        }

        var email = principal.FindFirst(ClaimTypes.Email)?.Value
                    ?? principal.FindFirst("email")?.Value;

        var name = principal.FindFirst("name")?.Value
                   ?? principal.FindFirst(ClaimTypes.GivenName)?.Value
                   ?? principal.FindFirst(ClaimTypes.Surname)?.Value;

        var picture = principal.FindFirst("picture")?.Value;

        return new UserInfo
        {
            Sub = subClaim.Value,
            Email = email,
            Name = name,
            Picture = picture
        };
    }

    public ClaimsPrincipal ToClaimsPrincipal()
    {
        var claims = new List<Claim>();

        if (!string.IsNullOrEmpty(Sub))
            claims.Add(new Claim("sub", Sub));
        if (!string.IsNullOrEmpty(Email))
            claims.Add(new Claim(ClaimTypes.Email, Email));
        if (!string.IsNullOrEmpty(Name))
            claims.Add(new Claim(ClaimTypes.Name, Name));
        if (!string.IsNullOrEmpty(Picture))
            claims.Add(new Claim("picture", Picture));

        var identity = new ClaimsIdentity(claims, "oidc");
        return new ClaimsPrincipal(identity);
    }


    public static string? GetClaimFallback(ClaimsPrincipal principal, params string[] types)
    {
        foreach (var t in types)
        {
            var c = principal.FindFirst(t);
            if (c != null) return c.Value;
        }
        return null;
    }
}
```


```csharp
internal sealed class PersistingAuthenticationStateProvider
    : AuthenticationStateProvider, IHostEnvironmentAuthenticationStateProvider, IDisposable
{
    private readonly PersistentComponentState _persistentComponentState;
    private readonly PersistingComponentStateSubscription _subscription;
    private Task<AuthenticationState>? _authenticationStateTask;

    public PersistingAuthenticationStateProvider(PersistentComponentState state)
    {
        _persistentComponentState = state;
        _subscription = state.RegisterOnPersisting(OnPersistingAsync, RenderMode.InteractiveWebAssembly);
    }

    public override Task<AuthenticationState> GetAuthenticationStateAsync()
        => _authenticationStateTask ??
            throw new InvalidOperationException($"Do not call {nameof(GetAuthenticationStateAsync)} outside of the DI scope for a Razor component. Typically, this means you can call it only within a Razor component or inside another DI service that is resolved for a Razor component.");

    public void SetAuthenticationState(Task<AuthenticationState> task)
    {
        _authenticationStateTask = task;
    }

    private async Task OnPersistingAsync()
    {
        var authenticationState = await GetAuthenticationStateAsync();
        var principal = authenticationState.User;

        if (principal.Identity?.IsAuthenticated == true)
        {
            _persistentComponentState.PersistAsJson(nameof(UserInfo), UserInfo.FromClaimsPrincipal(principal));
        }
    }

    public void Dispose()
    {
        _subscription.Dispose();
    }
}
```

Microsoft cung cấp CookieOidcRefresher để tự động refresh cookie khi token sắp hết hạn. 
Nhờ đó, người dùng không bị logout khi cookie hết hạn.

```csharp
public class CookieOidcRefresher
{
    public CookieOidcRefresher(IOptionsMonitor<OpenIdConnectOptions> oidcOptionsMonitor)
    {
        _oidcOptionsMonitor = oidcOptionsMonitor;
    }

    private readonly OpenIdConnectProtocolValidator _oidcTokenValidator = new()
    {
        // We no longer have the original nonce cookie which is deleted at the end of the authorization code flow having served its purpose.
        // Even if we had the nonce, it's likely expired. It's not intended for refresh requests. Otherwise, we'd use oidcOptions.ProtocolValidator.
        RequireNonce = false,
    };
    private readonly IOptionsMonitor<OpenIdConnectOptions> _oidcOptionsMonitor;

    public async Task ValidateOrRefreshCookieAsync(CookieValidatePrincipalContext validateContext, string oidcScheme)
    {
        var accessTokenExpirationText = validateContext.Properties.GetTokenValue("expires_at");
        if (!DateTimeOffset.TryParse(accessTokenExpirationText, out var accessTokenExpiration))
        {
            return;
        }

        var oidcOptions = _oidcOptionsMonitor.Get(oidcScheme);
        var now = oidcOptions.TimeProvider!.GetUtcNow();
        if (now + TimeSpan.FromMinutes(5) < accessTokenExpiration)
        {
            return;
        }

        var oidcConfiguration = await oidcOptions.ConfigurationManager!.GetConfigurationAsync(validateContext.HttpContext.RequestAborted);
        var tokenEndpoint = oidcConfiguration.TokenEndpoint ?? throw new InvalidOperationException("Cannot refresh cookie. TokenEndpoint missing!");

        using var refreshResponse = await oidcOptions.Backchannel.PostAsync(tokenEndpoint,
            new FormUrlEncodedContent(new Dictionary<string, string?>()
            {
                ["grant_type"] = "refresh_token",
                ["client_id"] = oidcOptions.ClientId,
                ["client_secret"] = oidcOptions.ClientSecret,
                ["scope"] = string.Join(" ", oidcOptions.Scope),
                ["refresh_token"] = validateContext.Properties.GetTokenValue("refresh_token"),
            }));

        if (!refreshResponse.IsSuccessStatusCode)
        {
            validateContext.RejectPrincipal();
            return;
        }

        var refreshJson = await refreshResponse.Content.ReadAsStringAsync();
        var message = new OpenIdConnectMessage(refreshJson);

        var validationParameters = oidcOptions.TokenValidationParameters.Clone();
        if (oidcOptions.ConfigurationManager is BaseConfigurationManager baseConfigurationManager)
        {
            validationParameters.ConfigurationManager = baseConfigurationManager;
        }
        else
        {
            validationParameters.ValidIssuer = oidcConfiguration.Issuer;
            validationParameters.IssuerSigningKeys = oidcConfiguration.SigningKeys;
        }

        var validationResult = await oidcOptions.TokenHandler.ValidateTokenAsync(message.IdToken, validationParameters);

        if (!validationResult.IsValid)
        {
            validateContext.RejectPrincipal();
            return;
        }

        var validatedIdToken = JwtSecurityTokenConverter.Convert(validationResult.SecurityToken as JsonWebToken);
        validatedIdToken.Payload["nonce"] = null;
        _oidcTokenValidator.ValidateTokenResponse(new()
        {
            ProtocolMessage = message,
            ClientId = oidcOptions.ClientId,
            ValidatedIdToken = validatedIdToken,
        });

        validateContext.ShouldRenew = true;
        validateContext.ReplacePrincipal(new ClaimsPrincipal(validationResult.ClaimsIdentity));

        var expiresIn = int.Parse(message.ExpiresIn, NumberStyles.Integer, CultureInfo.InvariantCulture);
        var expiresAt = now + TimeSpan.FromSeconds(expiresIn);
        validateContext.Properties.StoreTokens([
            new() { Name = "access_token", Value = message.AccessToken },
            new() { Name = "id_token", Value = message.IdToken },
            new() { Name = "refresh_token", Value = message.RefreshToken },
            new() { Name = "token_type", Value = message.TokenType },
            new() { Name = "expires_at", Value = expiresAt.ToString("o", CultureInfo.InvariantCulture) },
        ]);
    }
}
```

```csharp
internal static class CookieOidcServiceCollectionExtensions
{
    public static IServiceCollection ConfigureCookieOidcRefresh(this IServiceCollection services, string cookieScheme, string oidcScheme)
    {
        services.AddSingleton<CookieOidcRefresher>();
        services.AddOptions<CookieAuthenticationOptions>(cookieScheme).Configure<CookieOidcRefresher>((cookieOptions, refresher) =>
        {
            cookieOptions.Events.OnValidatePrincipal = context => refresher.ValidateOrRefreshCookieAsync(context, oidcScheme);
        });
        
        services.AddOptions<OpenIdConnectOptions>(oidcScheme).Configure(oidcOptions =>
        {
            var provider = oidcOptions.Authority ?? "";

            // Chỉ thêm offline_access nếu không phải Google
            if (!provider.Contains("accounts.google.com", StringComparison.OrdinalIgnoreCase))
            {
                oidcOptions.Scope.Add(OpenIdConnectScope.OfflineAccess);
            }

            oidcOptions.SaveTokens = true;
        });

        return services;
    }
}
```

### 3. Cấu hình appsettings.json (Server Project)

Ví dụ với Google:
```javascript
{
  "Oidc": {
    "Authority": "https://accounts.google.com",
    "ClientId": "YOUR_GOOGLE_CLIENT_ID",
    "ClientSecret": "YOUR_GOOGLE_CLIENT_SECRET",
    "CallbackPath": "/signin-oidc",
    "SignedOutCallbackPath": "/signout-callback-oidc",
    "ResponseType": "code"
  }
}
```

> Lưu client secret trong enviroment variables, không lưu trong appsettings.json (sử dụng user-secrets nếu là môi trường development).

### 4. Cấu hình Program.cs (Client Project)


```csharp
var builder = WebAssemblyHostBuilder.CreateDefault(args);

builder.Services.AddAuthorizationCore();
builder.Services.AddScoped<AuthenticationStateProvider, PersistentAuthenticationStateProvider>();

await builder.Build().RunAsync();
```


```csharp
internal sealed class PersistentAuthenticationStateProvider : AuthenticationStateProvider
{
    private static readonly Task<AuthenticationState> _defaultUnauthenticatedTask =
        Task.FromResult(new AuthenticationState(new ClaimsPrincipal(new ClaimsIdentity())));

    private readonly Task<AuthenticationState> _authenticationStateTask = _defaultUnauthenticatedTask;

    public PersistentAuthenticationStateProvider(PersistentComponentState state)
    {
        if (!state.TryTakeFromJson<UserInfo>(nameof(UserInfo), out var userInfo) || userInfo is null)
        {
            return;
        }

        _authenticationStateTask = Task.FromResult(new AuthenticationState(userInfo.ToClaimsPrincipal()));
    }

    public override Task<AuthenticationState> GetAuthenticationStateAsync() => _authenticationStateTask;
}
```

### 5. Cấu hình Routes.razor

```markup
<CascadingAuthenticationState>
    <Router AppAssembly="@typeof(Blogtify.Client.Program).Assembly">
        <Found Context="routeData">
            <AuthorizeRouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)">
                <NotAuthorized>
                    <p>Bạn cần đăng nhập để truy cập trang này.</p>
                </NotAuthorized>
            </AuthorizeRouteView>
        </Found>
        <NotFound>
            <PageTitle>Not found</PageTitle>
            <LayoutView Layout="@typeof(MainLayout)">
                <p role="alert">Sorry, there's nothing at this address.</p>
            </LayoutView>
        </NotFound>
    </Router>
</CascadingAuthenticationState>
```

### 6. Cấu hình Login/Logout

Sử dụng endpoint server để trigger flow:
```markup
@inject NavigationManager NavigationManager

<AuthorizeView>
    <Authorized>
        <span>Xin chào, @context.User.Identity?.Name!</span>
        <form action="authentication/logout" method="post">
            <AntiforgeryToken />
            <input type="hidden" name="returnUrl" value="@NavigationManager.Uri" />
            <button type="submit">Đăng xuất</button>
        </form>
    </Authorized>
    <NotAuthorized>
        <a href="authentication/login?returnUrl=@Uri.EscapeDataString(NavigationManager.Uri)">Đăng nhập</a>
    </NotAuthorized>
</AuthorizeView>
```

### 7. Gọi API protected
Sử dụng `DelegatingHandler` ở client để attach token từ server hoặc proxy 
qua server endpoint (authorized).
Ví dụ server endpoint:

```csharp
app.MapGet("/api/profile", async (HttpContext ctx) =>
{
    var token = await ctx.GetTokenAsync("access_token");
    // Gọi external API với token
}).RequireAuthorization();
```


# Authorization trong Blazor

Sau khi người dùng được xác thực, bước tiếp theo là phân quyền. Cách load `ClaimsPrincipal` có 
sự khác nhau giữa BFF và Non-BFF.

## Authorization trong khi Prerender

Trong giai đoạn prerender:

Nếu ứng dụng dùng Non-BFF, thì client chưa có token nên user chưa được xác thực. 
Do đó `<AuthorizeView>` tạm thời ở trạng thái Authorizing. Sau khi WASM hydrate, 
`AuthenticationStateProvider` cập nhật user → UI render lại.

Với BFF, vì cookie xác thực tồn tại ở server nên khi Prerender đã biết user 
→ `<AuthorizeView>` hiển thị đúng ngay từ đầu.

## Role-based Authorization

Phân quyền dựa trên **vai trò (Role)** là cách phổ biến nhất, sử dụng khi 
Identity Provider (Azure AD, IdentityServer, Keycloak...) trả về claim `"role"` hoặc `"roles"`.

Sử dụng `AuthorizeView`:
```markup
<AuthorizeView Roles="Administrator">
    <Authorized>
        <h3>Khu vực quản trị</h3>
        <p>Chỉ quản trị viên mới thấy được phần này.</p>
    </Authorized>
    <NotAuthorized>
        <p>Bạn không có quyền truy cập.</p>
    </NotAuthorized>
</AuthorizeView>
```

Hoặc trang/route được bảo vệ bằng attribute:
```markup
@attribute [Authorize(Roles = "Administrator")]
<h3>Admin Dashboard</h3>
```

> 💡 Trong BFF mode, role của user được server đưa vào Claims trong cookie vì vậy 
vẫn hoạt động bình thường ở cả prerender.

## Policy-based Authorization

Policy-based cho phép bạn định nghĩa quy tắc phức tạp hơn Role.

Định nghĩa Policy trong `Program.cs`:
```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("VerifiedEmail", policy =>
        policy.RequireClaim("email_verified", "true"));

    options.AddPolicy("EmployeeOnly", policy =>
        policy.RequireClaim("department", "IT", "HR"));
});
```

Sử dụng `AuthorizeView`:
```markup
<AuthorizeView Policy="EmployeeOnly">
    <Authorized>
        <p>Chào nhân viên phòng IT hoặc HR!</p>
    </Authorized>
    <NotAuthorized>
        <p>Bạn không có quyền truy cập nội dung này.</p>
    </NotAuthorized>
</AuthorizeView>
```

Hoặc trang/route được bảo vệ bằng attribute:
```markup
@attribute [Authorize(Policy = "VerifiedEmail")]
```

> Với BFF, mọi claim đều đến từ cookie do server cấp nên Policy hoạt động ngay cả 
trong prerender.

## Resource-based Authorization

Resource-based cho phép kiểm tra quyền động (dynamic), tùy vào từng đối tượng cụ thể. 
Ví dụ: User chỉ được sửa bài viết của chính mình hoặc xóa tài nguyên mà họ sở hữu.

Tạo Handler Resource:
```csharp
using Microsoft.AspNetCore.Authorization;

public class Document
{
    public string OwnerId { get; set; } = default!;
}

public class DocumentAuthorizationHandler : AuthorizationHandler<OperationAuthorizationRequirement, Document>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        OperationAuthorizationRequirement requirement,
        Document resource)
    {
        if (requirement.Name == "Edit" && 
            context.User.Identity?.Name == resource.OwnerId)
        {
            context.Succeed(requirement);
        }
        return Task.CompletedTask;
    }
}
```

Đăng ký handler trong `Program.cs`:
```csharp
builder.Services.AddSingleton<IAuthorizationHandler, DocumentAuthorizationHandler>();

```

Dùng trong Component
```markup
@page "/document/{Id}"
@inject IAuthorizationService AuthorizationService
@inject AuthenticationStateProvider AuthProvider

@if (canEdit)
{
    <button>Sửa tài liệu</button>
}
else
{
    <p>Bạn không có quyền chỉnh sửa tài liệu này.</p>
}

@code {
    Document doc = new() { OwnerId = "alice@example.com" };

    bool canEdit = false;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        var result = await AuthorizationService.AuthorizeAsync(user, doc, new OperationAuthorizationRequirement { Name = "Edit" });
        canEdit = result.Succeeded;
    }
}
```

> Xem thêm phần Authorization [tại đây](/post/authentication-va-authorization-trong-net#claims-based-authorization)

# Kết luận

Authentication và Authorization trong Blazor Web App phức tạp 
do prerender và render modes, nhưng BFF là cách an toàn và hiệu quả nhất. 
Hy vọng bài viết giúp bạn:
- Hiểu luồng OIDC với BFF.
- Xử lý authentication trong prerender.
- Triển khai các loại authorization.
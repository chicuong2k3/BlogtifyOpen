---
url: [/post/authentication-va-authorization-trong-blazor]
title: "Authentication và Authorization trong Blazor"
$attribute: PostMetadata(Id = 2, Title = "Authentication và Authorization trong Blazor", Category = "Blazor", LastModified = "21-10-2025")
$layout: BlogContentLayout
---

Từ .NET 8 trở đi, Microsoft hợp nhất hai mô hình Server và Blazor WebAssembly thành 
Blazor Web App, cho phép Prerender trên server (cải thiện SEO và tốc độ tải nhanh hơn). 
Chính điều này khiến Authentication trở nên phức tạp hơn 
vì trạng thái đăng nhập ban đầu được render ở server (nơi chưa có token), nhưng sau đó 
lại phải đồng bộ lại trên client khi Interactive được kích hoạt.

Bài viết này sẽ hướng dẫn chi tiết cách triển khai **Authentication** và **Authorization** 
trong **Blazor Web App**.

> 📘 Nếu bạn muốn hiểu chi tiết về `Authentication` và `Authorization` trong .NET, 
hãy xem lại bài viết [Authentication và Authorization trong .NET](/post/authentication-va-authorization-trong-net)

# Tổng quan về Authentication trong Blazor Web App

## Claims-based Identity

Blazor sử dụng mô hình Claims-based Identity để biểu diễn người dùng.

> 💡 Để hiểu rõ hơn về mô hình Claims-based Identity trong .NET hãy 
đọc [bài viết này](/post/authentication-va-authorization-trong-net#kien-truc-authentication-va-authorization-trong.net)

Các claim này được lưu trong `ClaimsPrincipal` và có thể truy cập thông 
qua `AuthenticationStateProvider`.

```markup
@page "/me"
@inject AuthenticationStateProvider AuthStateProvider

<h3>Thông tin người dùng</h3>

@code {
    private string? userName;
    private string? email;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity?.IsAuthenticated == true)
        {
            userName = user.Identity.Name;
            email = user.FindFirst(c => c.Type == "email")?.Value;
        }
    }
}
```


## Render Mode và ảnh hưởng đến Authentication

Từ .NET 8 trở đi, Blazor Web App có 3 chế độ render chính và mỗi render mode có cách 
xử lý Authentication khác nhau.

| Render Mode | Mô tả | Cơ chế Authentication |
|--------------|--------|------------------------|
| **Server** | UI được render và xử lý sự kiện trên server qua **SignalR**. | Sử dụng `HttpContext.User` (cookie). |
| **WebAssembly (WASM)** | Ứng dụng chạy hoàn toàn trên trình duyệt. | Sử dụng **OIDC (OpenID Connect)** với **PKCE Flow**, không có `HttpContext`. |
| **Auto** | Chạy với Server mode trước, sau đó chuyển sang WASM khi client tải xong. | Giai đoạn server dùng cookie; giai đoạn client dùng token OIDC. |


Khi dùng WASM với Prerender, HTML ban đầu render từ server để tăng tốc tải và SEO, sau đó 
WASM sẽ hydrate UI. 
Với **WASM + Prerender** thì ứng dụng hoạt động theo luồng sau:

<div class="mermaid">
flowchart LR
    A[User truy cập app] --> B[Server prerender HTML]
    B --> C[Trả về HTML tĩnh cho Browser]
    C --> D[Browser tải runtime WASM + .dll]
    D --> E[Client-side khởi động Blazor]
    E --> F[Xác thực với Identity Provider qua OIDC + PKCE]
    F --> G[Cập nhật lại AuthenticationState và UI]
</div>

## Authentication trong quá trình Prerender


Trong giai đoạn prerender thì HTML được render ở server nên chưa có quyền truy cập vào 
ProtectedLocalStorage hay token 
do đó `AuthenticationState.User.Identity.IsAuthenticated` sẽ luôn là `false`. 
Vì vậy, khi prerender bạn thường thấy `<AuthorizeView>` tạm thời hiển thị 
"Authorizing...". 

Sau khi Blazor tải và khởi động WebAssembly runtime:
- `AuthenticationStateProvider` khởi tạo lại trạng thái.
- Token được đọc từ sessionStorage hoặc localStorage.
- Toàn bộ component liên quan đến `AuthenticationState` được re-render.
- `AuthorizeView` chuyển từ trạng thái Authorizing sang Authorized nếu có token hợp lệ.

Ví dụ:
```markup
<AuthorizeView>
    <Authorized>
        <p>Chào mừng, @context.User.Identity.Name!</p>
    </Authorized>
    <Authorizing>
        <p>Đang kiểm tra trạng thái đăng nhập...</p>
    </Authorizing>
    <NotAuthorized>
        <p>Bạn chưa đăng nhập.</p>
    </NotAuthorized>
</AuthorizeView>
```

💡Nếu ứng dụng của bạn không cần SEO, bạn có thể tắt prerender để tránh flash UI.
```csharp
app.MapRazorComponents<App>()
   .AddInteractiveWebAssemblyRenderMode(options => options.Prerender = false);
```

# BFF và Non-BFF

## Authentication không dùng BFF (Non-BFF)

Khi bạn không sử dụng **Backend for Frontend (BFF)**, Blazor WebAssembly sẽ giao tiếp 
**trực tiếp với Identity Provider (IdP)** như Google, Facebook hoặc Azure AD thông qua 
**OpenID Connect (OIDC)** và **PKCE (Proof Key for Code Exchange)**. Token (access id/id_token) lưu trên browser (sessionStorage/localStorage). 

> Dùng cho Blazor WASM Standalone hoặc Blazor Web App với WASM Render Mode.

> Lưu ý: Facebook không hoàn toàn là OIDC mà là OAuth2 provider. Vì vậy dùng Facebook 
với non-BFF có rủi ro: Facebook trả OAuth code + access token 
nhưng Facebook không phát ID token theo OIDC. Microsoft khuyến nghị dùng BFF hoặc 
provider trung gian (Auth0, Azure AD B2C) để map Facebook sang OIDC-like claims.

### Cơ chế tổng quan

Microsoft sử dụng cơ chế **Authorization Code Flow with PKCE**, là tiêu chuẩn hiện nay 
cho SPA.  

Luồng hoạt động gồm 6 bước:
<div class="mermaid">
%%{init: {"theme": "default"}}%%
sequenceDiagram
    actor U as User
    participant B as Blazor App (WASM)
    participant IDP as Identity Provider (Google/Azure AD)
    participant API as Protected API (optional)

    U->>B: Click "Login"
    B->>IDP: Redirect (Authorization Request + PKCE)
    IDP->>U: Hiển thị form đăng nhập
    U->>IDP: Nhập thông tin xác thực
    IDP-->>B: Redirect + Authorization Code
    B->>IDP: Trao đổi Authorization Code để lấy Token
    IDP-->>B: Trả về Access Token + ID Token
    B->>B: Lưu token (sessionStorage/localStorage)
    B->>API: "Gọi API với Bearer Token (nếu có)"
</div>


- Toàn bộ quá trình diễn ra trên trình duyệt.
- Token không bao giờ được gửi về server (nếu bạn không dùng BFF).

### Triển khai

#### 1. Cài đặt package:

```bash
dotnet add package Microsoft.AspNetCore.Components.WebAssembly.Authentication

```

#### 2. Cấu hình OIDC trong Program.cs (Client Project):
```csharp
builder.Services.AddOidcAuthentication(options =>
{
    builder.Configuration.Bind("Oidc", options.ProviderOptions);
});
```

#### 3. Thêm cấu hình OIDC trong wwwroot/appsettings.json (Client Project):

Ví dụ với Google Identity Platform:
```javascript
{
  "Oidc": {
    "Authority": "https://accounts.google.com",
    "ClientId": "YOUR_GOOGLE_CLIENT_ID",
    "RedirectUri": "https://localhost:7063/authentication/login-callback",
    "PostLogoutRedirectUri": "https://localhost:7063/",
    "ResponseType": "code",
    "DefaultScopes": [
      "openid",
      "profile",
      "email"
    ]
  }
}
```

> Đảm bảo bạn đã đăng ký Redirect URI trong Google Cloud Console (OAuth 2.0 Client IDs). 
Nếu không thì Google sẽ trả lỗi redirect_uri_mismatch.

#### 4. Thêm component xác thực:

Thêm vào Component `Authentication.razor`:
```markup
@page "/authentication/{action}"
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication

<RemoteAuthenticatorView Action="@Action" />
@code {
    [Parameter] public string? Action { get; set; }
}
```

Component này sẽ xử lý toàn bộ OIDC flow cho bạn.

#### 5. Thêm CascadingAuthenticationState vào Routes.razor

```markup
<CascadingAuthenticationState>
    <Router AppAssembly="@typeof(Program).Assembly">
        <Found Context="routeData">
            <RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" />
        </Found>
        <NotFound>
            <LayoutView Layout="@typeof(MainLayout)">
                <p>Trang không tồn tại.</p>
            </LayoutView>
        </NotFound>
    </Router>
</CascadingAuthenticationState>
```

#### 6. Cấu hình Login/Logout

```markup
@inject NavigationManager NavigationManager

<AuthorizeView>
    <Authorized>
        <span>Xin chào, @context.User.Identity?.Name!</span>
        <button @onclick="Logout">Đăng xuất</button>
    </Authorized>
    <NotAuthorized>
        <button @onclick="Login">Đăng nhập</button>
    </NotAuthorized>
</AuthorizeView>

@code {
    void Login() => NavigationManager.NavigateTo("authentication/login");
    void Logout() => NavigationManager.NavigateTo("authentication/logout");
}
```

#### 7. Cách gọi API (nếu cần)

```markup
@inject IAccessTokenProvider TokenProvider 
@inject HttpClient Http

@code {
    protected override async Task OnInitializedAsync()
    {
        var tokenResult = await TokenProvider.RequestAccessToken();
        if (tokenResult.TryGetToken(out var token))
        {
            Http.DefaultRequestHeaders.Authorization =
                new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", token.Value);

            var data = await Http.GetStringAsync("https://localhost:5001/api/profile");
        }
    }
}
```

## Authentication với BFF

Server (host) thực hiện toàn bộ OIDC flow. 

> Dùng khi ứng dụng yêu cầu bảo mật cao. Có thể dùng được cho cả WASM, Server hoặc Auto Render Mode.

### Cơ chế tổng quan

<div class="mermaid">
sequenceDiagram
    participant U as User
    participant B as Blazor App (Browser)
    participant S as Server (BFF + Blazor Host)
    participant IDP as Identity Provider (OIDC)
    participant API as Protected API

    U->>B: Truy cập ứng dụng
    B->>S: Gửi request (có thể prerender)
    S->>IDP: Redirect đến trang đăng nhập
    IDP->>U: Hiển thị form đăng nhập
    U->>IDP: Nhập thông tin xác thực
    IDP-->>S: Trả Authorization Code
    S->>IDP: Trao đổi code lấy token
    IDP-->>S: Trả Access + Refresh Token
    S-->>B: Gửi HTTP-only cookie
    B->>S: Gọi API nội bộ qua Cookie
    S->>API: Gắn Access Token và gọi thay mặt user
</div>

- Token (access/refresh) chỉ tồn tại ở server, không bao giờ nằm trong browser.
- Client chỉ giữ cookie an toàn (HttpOnly, SameSite=Strict, Secure).
- API backend chỉ tin tưởng các request đến từ chính BFF (có cookie hợp lệ). 
Trong kiến trúc này, Browser không bao giờ gọi API trực tiếp. 
Mọi request đều đi qua BFF (Host Server), giúp che giấu Access Token khỏi client.

### Triển khai

#### 1. Cấu hình Program.cs (Server Project):
```csharp
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.Cookies;
using Microsoft.AspNetCore.Authentication.OpenIdConnect;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorComponents()
    .AddInteractiveWebAssemblyComponents();

builder.Services.AddAuthentication(options =>
{
    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme;
})
.AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, options =>
{
    options.Cookie.HttpOnly = true;
    options.Cookie.SameSite = SameSiteMode.Strict;
    options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
})
.AddOpenIdConnect(OpenIdConnectDefaults.AuthenticationScheme, options =>
{
    builder.Configuration.Bind("Oidc", options);

    options.ResponseType = "code";
    options.SaveTokens = false; // Token không lưu trong cookie
    options.GetClaimsFromUserInfoEndpoint = true;
});

builder.Services.AddAuthorization();
builder.Services.AddControllersWithViews();
builder.Services.AddRazorComponents()
       .AddInteractiveWebAssemblyRenderMode();

var app = builder.Build();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();
app.MapRazorComponents<App>()
   .AddInteractiveWebAssemblyRenderMode();

app.Run();
```

#### 2. Cấu hình trong appsettings.json (Server)

Ví dụ với Azure AD:
```javascript
{
  "Oidc": {
    "Authority": "https://login.microsoftonline.com/{tenant-id}/v2.0",
    "ClientId": "your-client-id",
    "ClientSecret": "your-client-secret",
    "CallbackPath": "/signin-oidc",
    "SignedOutCallbackPath": "/signout-callback-oidc",
    "ResponseType": "code",
    "Scope": "openid profile email api://your-api-id/access_as_user"
  }
}
```

#### 3. Cấu hình Login/Logout

Tương tự phần Non-BFF

# Authorization trong Blazor

Sau khi người dùng được xác thực, bước tiếp theo là phân quyền. Cách load `ClaimsPrincipal` có 
sự khác nhau giữa BFF và Non-BFF.

## Authorization trong khi Prerender

Trong giai đoạn prerender:

Nếu ứng dụng dùng Non-BFF, thì client chưa có token nên user chưa được xác thực. 
Do đó `<AuthorizeView>` tạm thời ở trạng thái Authorizing. Sau khi WASM hydrate, 
`AuthenticationStateProvider` cập nhật user → UI render lại.

Với BFF, vì cookie xác thực tồn tại ở server nên khi Prerender đã biết user 
→ `<AuthorizeView>` hiển thị đúng ngay từ đầu.

## Role-based Authorization

Phân quyền dựa trên **vai trò (Role)** là cách phổ biến nhất, sử dụng khi 
Identity Provider (Azure AD, IdentityServer, Keycloak...) trả về claim `"role"` hoặc `"roles"`.

Sử dụng `AuthorizeView`:
```markup
<AuthorizeView Roles="Administrator">
    <Authorized>
        <h3>Khu vực quản trị</h3>
        <p>Chỉ quản trị viên mới thấy được phần này.</p>
    </Authorized>
    <NotAuthorized>
        <p>Bạn không có quyền truy cập.</p>
    </NotAuthorized>
</AuthorizeView>
```

Hoặc trang/route được bảo vệ bằng attribute:
```markup
@attribute [Authorize(Roles = "Administrator")]
<h3>Admin Dashboard</h3>
```

> 💡 Trong BFF mode, role của user được server đưa vào Claims trong cookie vì vậy 
vẫn hoạt động bình thường ở cả prerender.

## Policy-based Authorization

Policy-based cho phép bạn định nghĩa quy tắc phức tạp hơn Role.

Định nghĩa Policy trong `Program.cs`:
```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("VerifiedEmail", policy =>
        policy.RequireClaim("email_verified", "true"));

    options.AddPolicy("EmployeeOnly", policy =>
        policy.RequireClaim("department", "IT", "HR"));
});
```

Sử dụng `AuthorizeView`:
```markup
<AuthorizeView Policy="EmployeeOnly">
    <Authorized>
        <p>Chào nhân viên phòng IT hoặc HR!</p>
    </Authorized>
    <NotAuthorized>
        <p>Bạn không có quyền truy cập nội dung này.</p>
    </NotAuthorized>
</AuthorizeView>
```

Hoặc trang/route được bảo vệ bằng attribute:
```markup
@attribute [Authorize(Policy = "VerifiedEmail")]
```

> Với BFF, mọi claim đều đến từ cookie do server cấp nên Policy hoạt động ngay cả 
trong prerender.

## Resource-based Authorization

Resource-based cho phép kiểm tra quyền động (dynamic), tùy vào từng đối tượng cụ thể. 
Ví dụ: User chỉ được sửa bài viết của chính mình hoặc xóa tài nguyên mà họ sở hữu.

Tạo Handler Resource:
```csharp
using Microsoft.AspNetCore.Authorization;

public class Document
{
    public string OwnerId { get; set; } = default!;
}

public class DocumentAuthorizationHandler : AuthorizationHandler<OperationAuthorizationRequirement, Document>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        OperationAuthorizationRequirement requirement,
        Document resource)
    {
        if (requirement.Name == "Edit" && 
            context.User.Identity?.Name == resource.OwnerId)
        {
            context.Succeed(requirement);
        }
        return Task.CompletedTask;
    }
}
```

Đăng ký handler trong `Program.cs`:
```csharp
builder.Services.AddSingleton<IAuthorizationHandler, DocumentAuthorizationHandler>();
```

Dùng trong Component
```markup
@page "/document/{Id}"
@inject IAuthorizationService AuthorizationService
@inject AuthenticationStateProvider AuthProvider

@if (canEdit)
{
    <button>Sửa tài liệu</button>
}
else
{
    <p>Bạn không có quyền chỉnh sửa tài liệu này.</p>
}

@code {
    Document doc = new() { OwnerId = "alice@example.com" };

    bool canEdit = false;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        var result = await AuthorizationService.AuthorizeAsync(user, doc, new OperationAuthorizationRequirement { Name = "Edit" });
        canEdit = result.Succeeded;
    }
}
```

> Xem thêm phần Authorization [tại đây](/post/authentication-va-authorization-trong-net#claims-based-authorization)

# Kết luận

Authentication và Authorization trong Blazor là một chủ đề phức tạp, 
nhất là khi có thêm prerender. 
Hy vọng qua bài viết này, bạn đã có thể:
- Nắm vững luồng OIDC (khi dùng và không dùng BFF).
- Hiểu về cơ chế Authentication trong giai đoạn prerender.
- Cách triển khai phân quyền trong Blazor.
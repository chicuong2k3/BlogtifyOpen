---
url: [/post/thoat-khoi-tutorial-hell-bi-quyet-lam-chu-moi-ui-framework]
title: "Làm chủ mọi UI Framework qua 4 pattern"
$attribute: PostMetadata(Id = 1, Title = " Làm chủ mọi UI Framework qua 4 pattern", Category = "Software Architecture", LastModified = "04-10-2025", IsDraft=true)
$layout: BlogContentLayout
---

Từ khi AI ra đời và bùng nổ như một cuộc cách mạng, nhiều người reo hò rằng 
"Viết code giờ ai cũng làm được! AI sẽ thay thế lập trình viên, chỉ cần gõ prompt là ra." 
Họ tưởng tượng một thế giới nơi code là thứ "dễ như ăn kẹo", nơi bạn không cần học gì 
sâu xa, chỉ việc ra lệnh cho AI "Viết app X cho tôi" là xong. Nhưng họ không biết rằng 
thứ thực sự làm nên sự khác biệt, thứ quyết định bạn có thể xây dựng phần mềm bền vững, 
dễ bảo trì và mở rộng hay không, chính là các pattern.

Bài viết này chúng ta sẽ tìm hiểu về 4 pattern UI quan trọng trong lập trình UI: MVC, MVVM, Flux và MVU.


# MVC - Người đàn anh tiên phong
 
Hãy quay ngược thời gian về cuối những năm 1970, tại Xerox PARC, Trygve Reenskaug, 
một nhà khoa học máy tính Na Uy, 
đang vật lộn với một dự án 

<img src="/mvc.webp" alt="MVC" loading="lazy" />
<br />

Nhờ cách tách biệt này giúp code gọn gàng và dễ mở rộng hơn so với việc trộn tất cả vào một chỗ.
MVC nhanh chóng trở thành nền tảng cho nhiều framework sau này như .NET MVC hay Ruby on Rails. 
Nhưng khi web ngày càng phức tạp thì Controller bị phình to vì chứa 
quá nhiều logic. Hơn nữa, luồng dữ liệu hai chiều (View có thể tác động ngược lên Model) 
khiến cho State Management và debug trở nên khó khăn.

# MVVM - Lời giải cho ứng dụng desktop

Khoảng năm 2005, cùng với sự ra mắt của WPF, Microsoft giới thiệu **MVVM (Model–View–ViewModel)** 
nhằm chinh phục những ứng dụng desktop phức tạp.

<img src="/mvvm.webp" alt="MVVM" loading="lazy" />
<br />

MVVM giữ lại Model nhưng thay Controller bằng ViewModel. ViewModel chuẩn bị dữ liệu 
sẵn sàng cho View, đồng thời cung cấp các command để xử lý thao tác người dùng. 
View chỉ tập trung hiển thị và kết nối với ViewModel thông qua binding.

Điểm mạnh của MVVM nằm ở binding hai chiều. Khi dữ liệu thay đổi, UI tự động cập nhật, 
ngược lại, khi người dùng thao tác trên UI, dữ liệu cũng được đồng bộ. 
Điều này đặc biệt phù hợp với ứng dụng desktop và mobile, nơi cần xử lý nhiều state động, 
nhiều thành phần UI phức tạp và thay đổi liên tục.

Trên web, MVVM từng được thử nghiệm với **Knockout.js** và một phần trong Angular.  
Những thư viện này mang cơ chế binding hai chiều vào DOM, giúp lập trình viên 
viết ít code thao tác trực tiếp hơn. Tuy nhiên, binding hai chiều dần lộ nhược điểm về 
hiệu năng và khó debug ở app lớn, dẫn đến sự chuyển dịch sang các kiến trúc unidirectional,  
nổi bật nhất là Flux.

# Flux và luồng dữ liệu một chiều

Khi single-page app (SPA) bùng nổ, đặc biệt với React năm 2013, web cần một cách tiếp cận 
mới để kiểm soát sự phức tạp. Năm 2014, Facebook giới thiệu Flux như một pattern đi 
kèm React, đặt nền tảng cho khái niệm luồng dữ liệu một chiều (unidirectional data flow).

<img src="/flux.webp" alt="Flux" loading="lazy" />
<br />

Trong Flux, mọi thứ đi theo một hướng duy nhất: Người dùng thao tác trên View tạo ra 
Action (như click button). Action được gửi qua Dispatcher để cập nhật Store 
(nơi lưu state toàn cục), sau đó View sẽ được render lại dựa trên state mới từ Store. 
Luồng chảy rõ ràng này loại bỏ tình trạng hỗn loạn thường gặp ở MVC truyền thống, 
làm state dễ dự đoán và debug hơn.

Flux mang lại lợi ích lớn cho các ứng dụng web phức tạp với nhiều thành phần tương tác, 
và nó sinh ra các thư viện như Redux cho React, NgRx cho Angular, hay Vuex cho Vue. 
Có thể nói rằng Flux đã thay đổi cách chúng ta quản lý state trong UI hiện đại. 

# MVU - Elm và triết lý bất biến  

Trong giai đoạn 2012 đến 2015, Elm (ngôn ngữ do Evan Czaplicki sáng tạo) giới thiệu 
**MVU (Model–View–Update)**. MVU có thể coi như phiên bản tinh gọn và functional hóa của Flux. 

Ở MVU, Model là state bất biến.  
View là một pure function, nhận đầu vào là Model và trả về View.  
Mọi thay đổi đến từ Update, một function nhận vào message (tương tự Action) và Model cũ, rồi trả về Model mới. 

Điểm khác biệt quan trọng là không ai được chỉnh sửa trực tiếp state.  
Mỗi thay đổi tạo ra một Model hoàn toàn mới.  

Triết lý bất biến của MVU sau này ảnh hưởng mạnh đến nhiều framework khác, 
từ Flutter cho đến Elmish.  

<img src="/mvu.webp" alt="MVU" loading="lazy">
<br />

---

Nhìn lại, mỗi pattern xuất hiện đều nhằm khắc phục hạn chế của thế hệ trước.  
MVC đưa ra tách biệt trách nhiệm, MVVM giải quyết đồng bộ dữ liệu cho desktop và mobile, 
Flux kiểm soát luồng dữ liệu trên web hiện đại, còn MVU bổ sung triết lý bất biến để state dễ dự đoán.  
Khi hiểu rõ điểm chung này, bạn sẽ thấy mọi framework UI thực chất chỉ là biến thể triển khai.  

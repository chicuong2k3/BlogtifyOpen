---
url: [/post/authentication-va-authorization-trong-net]
title: "Authentication và Authorization trong .NET"
$attribute: PostMetadata(Id = "6273283b-3660-4bab-bf9a-14240945c915", Title = "Authentication và Authorization trong .NET", Category = "Bảo mật", LastModified = "19-10-2025")
$layout: BlogContentLayout
---

Trong các ứng dụng web và API ngày nay, bảo mật là một phần **không thể thiếu**. Dù bạn 
xây dựng hệ thống quản lý nội bộ, thương mại điện tử hay ứng dụng SaaS thì việc đảm bảo 
người dùng **được xác thực chính xác** và **chỉ truy cập được tài nguyên họ được phép** 
là yêu cầu tối thiểu. Bài viết này sẽ giúp bạn nắm rõ:
- Phân biệt Authentication và Authorization.
- Hiểu kiến trúc Authentication và Authorization trong ASP.NET Core.
- Triển khai Cookie Authentication Web App.
- Triển khai JWT Bearer Authentication cho API.
- Khám phá các cơ chế Authorization.
- Các best practices khi thiết kế hệ thống.

# Authentication và Authorization là gì?

Trước khi đi vào chi tiết trong .NET, chúng ta cần phân biệt rõ hai khái niệm quan trọng 
mà mọi lập trình viên đều phải nắm vững là Authentication (xác thực) và Authorization (phân quyền). 
Dù nghe có vẻ quen thuộc nhưng rất nhiều người vẫn nhầm lẫn giữa chúng. 
- Authentication (Xác thực): Là quá trình xác minh danh tính của một người, tức là kiểm 
tra xem bạn thật sự là ai. Ví dụ như khi bạn đến sân bay, nhân viên an ninh yêu cầu bạn 
xuất trình căn cước công dân hoặc hộ chiếu và vé máy bay. Họ kiểm tra ảnh, tên và mã vé để 
chắc chắn rằng bạn chính là người đã đặt vé. Đó chính là xác thực. 
- Authorization (Phân quyền): Là quá trình kiểm tra quyền hạn truy cập hoặc hành động 
mà bạn được phép thực hiện sau khi đã xác thực danh tính. Ví dụ như sau khi bạn đã qua cửa 
an ninh và lên máy bay, vé hạng phổ thông (Economy) chỉ cho phép bạn ngồi ở khoang phổ thông, 
trong khi vé hạng thương gia (Business Class) được phép ngồi ở khoang riêng và sử dụng phòng chờ VIP. 
Dù cả hai hành khách đều đã được xác thực, quyền truy cập của họ khác nhau dựa trên "vai trò" (class). 
Đây chính là phân quyền. 

<div class="mermaid"> 
flowchart LR
    A[Hành khách đến sân bay] --> B[Xác thực danh tính - kiểm tra CCCD hoặc hộ chiếu và vé]
    B --> C{Đã xác thực hợp lệ?}
    C -- Không --> D[Không cho phép lên máy bay]
    C -- Có --> E[Phân quyền theo loại vé]
    E --> F[Vé Economy - Khoang phổ thông]
    E --> G[Vé Business - Phòng chờ VIP + khoang thương gia]
</div>

Tóm lại thì: 
> **Authentication** trả lời cho câu hỏi **Bạn là ai**  
> **Authorization** trả lời cho câu hỏi **Bạn được phép làm gì**

# Kiến trúc Authentication và Authorization trong .NET

.NET được thiết kế với kiến trúc middleware linh hoạt. Cơ chế xác thực 
(Authentication) và phân quyền (Authorization) hoạt động như hai tầng 
độc lập trong pipeline nhưng liên kết chặt chẽ với nhau. 
Nó được xây dựng dựa trên một số thành phần chính. 
Bạn có thể hình dung mối quan hệ giữa các thành phần này qua sơ đồ dưới đây: 

<div class="mermaid">
flowchart TD
    A[HTTP Request] --> B[Authentication Middleware]
    B --> C{Authentication Result}
    C -->|Thành công| D[ClaimsPrincipal]
    C -->|Thất bại| E[Challenge/Forbid]
    D --> F[Authorization Middleware]
    F --> G{Authorization Result}
    G -->|Thành công| H[Access Granted]
    G -->|Thất bại| I[Access Denied]
</div>


##  Authentication Handler

Đây là bộ não trực tiếp thực hiện các nhiệm vụ xác thực cụ thể. 
Mỗi loại xác thực sẽ có một Handler riêng, ví dụ:
- `CookieAuthenticationHandler`: Quản lý xác thực dựa trên cookie.
- `JwtBearerHandler`: Quản lý xác thực dựa trên JWT.
- `OpenIdConnectHandler`: Quản lý xác thực theo chuẩn OpenIDConnect hay WS-Federation.
- `RemoteAuthenticationHandler`: Quản lý xác thực từ xa như Google, Facebook...

Một handler có trách nhiệm xử lý ba nhiệm vụ quan trọng:
- **Authenticate:** Đọc và xác thực thông tin đăng nhập (cookie hoặc token) và xây dựng danh tính 
người dùng (đối tượng `ClaimsPrincipal`).
- **Challenge:** Phản hồi khi một người dùng chưa đăng nhập cố truy cập vào 
tài nguyên được bảo vệ (như chuyển hướng người dùng đến trang đăng nhập hoặc trả về HTTP 401 Unauthorized).
- **Forbid:** Phản hồi khi một người dùng đã đăng nhập nhưng không có 
quyền truy cập (trả về HTTP 403 Forbidden).

## Authentication Scheme

`Scheme` là một cái tên duy định danh cho một cấu hình xác thực cụ thể, 
giúp hệ thống biết cần sử dụng Handler nào. Khi cấu hình, bạn có thể đăng ký 
nhiều Scheme, ví dụ scheme dùng JWT cho API, một scheme khác dùng Cookie cho MVC web.

```csharp
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, options => builder.Configuration.Bind("JwtSettings", options))
    .AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, options => builder.Configuration.Bind("CookieSettings", options));
```

Khi thực thi, hệ thống sẽ dựa vào tên `Scheme` để biết cần sử dụng handler nào cho yêu cầu 
hiện tại.

## IAuthenticationService

Đây là "bộ não" điều phối, cung cấp các phương thức:
- `SignInAsync`: Tạo thông tin đăng nhập (cookie hoặc token).
- `SignOutAsync`: Xóa thông tin đăng nhập.
- `ChallengeAsync()`: Gửi phản hồi yêu cầu xác thực (redirect hoặc 401).
- `AuthenticateAsync`: Xác thực yêu cầu hiện tại và trả về `AuthenticateResult`.

## ClaimsPrincipal - Danh tính của người dùng

Sau khi xác thực thành công, thông tin người dùng được lưu vào 
`ClaimsPrincipal`, một đối tượng đại diện cho người dùng trong hệ thống. 
Cấu trúc của `ClaimsPrincipal` gồm:
- `Claim`: Là một mảnh thông tin về người dùng, được lưu trữ dưới dạng cặp key-value, tương tự 
như một dòng thông tin trong căn cước công dân (Họ và tên: Nguyễn Văn A; Ngày sinh: 01/01/1990). 
- `ClaimsIdentity`: Một tập hợp các Claim, tương tự như căn cước công dân, giấy phép lái xe, hộ chiếu.
- `ClaimsPrincipal`: Chứa một hoặc nhiều ClaimsIdentity, đại diện cho người dùng hiện tại. Giống 
việc một người có thể có nhiều loại giấy tờ là căn cước công dân, giấy phép lái xe, hộ chiếu. 

```csharp
// Tưởng tượng ClaimsPrincipal như một chiếc ví chứa nhiều loại giấy tờ của một người
var principal = new ClaimsPrincipal();

// Giấy tờ 1: Căn cước công dân (Identity chính)
var nationalId = new ClaimsIdentity(new[]
{
    new Claim(ClaimTypes.NameIdentifier, "12345"),  // Số CCCD
    new Claim(ClaimTypes.Name, "Nguyễn Văn A"),     // Họ tên
    new Claim(ClaimTypes.DateOfBirth, "1990-01-01") // Ngày sinh
}, "NationalID");

// Giấy tờ 2: Bằng lái xe (Identity thứ 2)
var driverLicense = new ClaimsIdentity(new[]
{
    new Claim("LicenseNumber", "DL-123456"),
    new Claim("VehicleType", "B2"),
    new Claim("ExpiryDate", "2030-12-31")
}, "DriverLicense");

// Cho cả 2 vào ví
principal.AddIdentity(nationalId);
principal.AddIdentity(driverLicense);
```

Trong ứng dụng .NET, bạn có thể truy cập đối tượng này thông qua `HttpContext.User`:

```csharp
var userName = HttpContext.User.Identity.Name;
var roles = HttpContext.User.Claims
                .Where(c => c.Type == ClaimTypes.Role)
                .Select(c => c.Value);
```

# Cookie Authentication (thường dùng cho Web App như .NET MVC và Razor Pages)

Cookie Authentication là một trong những phương pháp xác thực phổ biến nhất trong các ứng dụng web. 
Nó sử dụng cookie để lưu trữ thông tin xác thực của người dùng sau khi họ đăng nhập thành công. 
Dưới đây là cách triển khai Cookie Authentication trong .NET:

**Bước 1: Cấu hình Cookie Authentication**

```csharp
var builder = WebApplication.CreateBuilder(args);

// Đăng ký dịch vụ xác thực với Scheme mặc định là Cookies
builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie(options =>
    {
        options.Cookie.Name = "MyAppCookie";
        options.LoginPath = "/Account/Login"; // Đường dẫn tới trang đăng nhập
        options.AccessDeniedPath = "/Account/AccessDenied"; // Đường dẫn khi bị từ chối truy cập
        options.ExpireTimeSpan = TimeSpan.FromMinutes(20); // Thời gian cookie hết hạn
        options.SlidingExpiration = true; // Tự động gia hạn nếu còn hoạt động
        options.Cookie.HttpOnly = true; // Bảo vệ cookie khỏi JavaScript
        options.Cookie.SecurePolicy = CookieSecurePolicy.Always; // Chỉ gửi cookie qua HTTPS
    });

builder.Services.AddControllersWithViews();

var app = builder.Build();

app.UseRouting();

// UseAuthentication phải được đặt sau UseRouting và trước UseAuthorization
app.UseAuthentication(); // Middleware này thiết lập HttpContext.User
app.UseAuthorization(); // Middleware này thực thi việc phân quyền

app.MapControllers();

app.Run();
```

**Bước 2: Đăng nhập và tạo Cookie**

Khi người dùng gửi thông tin đăng nhập, bạn sẽ tạo `ClaimsPrincipal` rồi 
gọi `SignInAsync` để tạo và lưu cookie:

```csharp
[HttpPost]
public async Task<IActionResult> Login(LoginModel model)
{
    if (!ModelState.IsValid)
        return View(model);

    var user = await AuthenticateUser(model.UserName, model.Password);
    if (user == null)
    {
        ModelState.AddModelError("", "Tên đăng nhập hoặc mật khẩu không đúng");
        return View(model);
    }

    var claims = new List<Claim>
    {
        new Claim(ClaimTypes.NameIdentifier, user.Id),
        new Claim(ClaimTypes.Name, user.UserName),
        new Claim(ClaimTypes.Role, "Member"),
        new Claim("FavoriteDrink", "Tea")
    };

    var identity = new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);
    var principal = new ClaimsPrincipal(identity);

    await HttpContext.SignInAsync(
        CookieAuthenticationDefaults.AuthenticationScheme, 
        principal,
        new AuthenticationProperties
        {
            IsPersistent = model.RememberMe, // Ghi nhớ đăng nhập
            ExpiresUtc = DateTimeOffset.UtcNow.AddMinutes(20)
        });

    return LocalRedirect(model.ReturnUrl ?? "/");
}
```

Để đăng xuất, bạn chỉ cần gọi `SignOutAsync`, hệ thống sẽ xóa cookie xác thực:
```csharp
[Authorize]
public async Task<IActionResult> Logout()
{
    await HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);
    return RedirectToAction("Index", "Home");
}
```

# JWT Bearer Authentication (thường dùng cho API)

## JWT là gì?

JWT (JSON Web Token) là một token tự chứa (self-contained) dưới dạng json gồm 3 phần:
- Header: loại thuật toán ký (ví dụ HS256).
- Payload: chứa các `claims` (thông tin về người dùng như id, email...).
- Signature: dùng để xác minh tính toàn vẹn (được ký bằng secret key).

Ví dụ:

```javascript
{
  "sub": "user123",
  "name": "Alice",
  "role": "Admin",
  "exp": 1734567890
}
```

## Cấu hình JWT Bearer trong .NET

Đầu tiên cần đăng ký Service và Middleware:

```csharp
// Program.cs
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;

var builder = WebApplication.CreateBuilder(args);

// Cấu hình JwtSettings trong appsettings.json (Issuer, Audience, SecretKey, ExpireMinutes)
var jwtSettings = builder.Configuration.GetSection("JwtSettings");

// Thêm Authentication với JWT Bearer
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.RequireHttpsMetadata = true;
    options.SaveToken = true;
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidIssuer = jwtSettings["Issuer"],

        ValidateAudience = true,
        ValidAudience = jwtSettings["Audience"],

        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings["SecretKey"])),

        RequireExpirationTime = true,
        ValidateLifetime = true,
        ClockSkew = TimeSpan.FromSeconds(30)
    };
});

builder.Services.AddAuthorization();
```

Tiếp theo tạo JWT:
```csharp
public class JwtTokenService
{
    private readonly IConfiguration _config;

    public JwtTokenService(IConfiguration config)
    {
        _config = config;
    }

    public string GenerateToken(User user)
    {
        var jwtSettings = _config.GetSection("JwtSettings");
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings["SecretKey"]));
        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

        var claims = new List<Claim>
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id),
            new Claim(ClaimTypes.Name, user.Username),
            new Claim(ClaimTypes.Role, user.Role),
            // thêm claim khác nếu cần
        };

        var token = new JwtSecurityToken(
            issuer: jwtSettings["Issuer"],
            audience: jwtSettings["Audience"],
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(double.Parse(jwtSettings["ExpireMinutes"])),
            signingCredentials: creds
        );

        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}
```

# Authorization - Kiểm soát quyền truy cập

Sau khi xác thực, giai đoạn phân quyền (Authorization) sẽ xác định người dùng được phép làm gì. 

<div class="mermaid"> 
flowchart LR 
    A[ClaimsPrincipal] --> B[Authorization Middleware] 
    B --> C{Policy / Role / Resource} 
    C -- Không đủ quyền --> D[403 Forbidden] 
    C -- Có quyền --> E[Action được thực thi] 
</div>

## Role-based Authorization

Phân quyền dựa theo vai trò. 
Áp dụng khi bạn gán role cho người dùng (Admin, Manager, Premium Member, ...):

```csharp
[Authorize(Roles = "Admin,Manager")]
public IActionResult Dashboard()
{
    return View();
}
```

Ưu điểm: Dễ hiểu, dễ cấu hình.
Nhược điểm: Cứng nhắc, không phù hợp hệ thống quyền phức tạp.

## Claims-based Authorization

Phân quyền dựa vào giá trị cụ thể của `Claim`:

```csharp
[Authorize(Policy = "CanDrinkTea")]
public IActionResult TeaLounge() => View();
```

Cấu hình policy:

```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("CanDrinkTea", policy =>
        policy.RequireClaim("FavoriteDrink", "Tea"));
});
```

Ưu điểm: Linh hoạt hơn Role-based.
Nhược điểm: Không xử lý được logic phức tạp (ví dụ tuổi, sở hữu tài nguyên...).

## Policy-based Authorization

Cho phép kết hợp nhiều điều kiện (role, claim, custom logic). 
Dùng khi quyền truy cập phức tạp, cần custom logic. 
Ví dụ custom handler:

Tạo requirement và handler:
```csharp
public class MinimumAgeRequirement : IAuthorizationRequirement
{
    public int Age { get; }
    public MinimumAgeRequirement(int age) => Age = age;
}

public class MinimumAgeHandler : AuthorizationHandler<MinimumAgeRequirement>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context, MinimumAgeRequirement requirement)
    {
        var birthDateClaim = context.User.FindFirst(c => c.Type == "BirthDate");
        if (birthDateClaim == null)
            return Task.CompletedTask;

        var birthDate = DateTime.Parse(birthDateClaim.Value);
        var age = DateTime.Today.Year - birthDate.Year;

        if (age >= requirement.Age)
            context.Succeed(requirement);

        return Task.CompletedTask;
    }
}
```

Đăng ký policy:

```csharp
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("AtLeast18", policy =>
        policy.Requirements.Add(new MinimumAgeRequirement(18)));
});

builder.Services.AddSingleton<IAuthorizationHandler, MinimumAgeHandler>();
```

Ưu điểm: Mạnh mẽ, linh hoạt.
Nhược điểm: Code nhiều hơn.

## Resource-based Authorization

Dùng resource-based Authorization khi quyền phụ thuộc cụ thể vào một tài nguyên cụ thể
(document, order hay photo). 
Ví dụ: Khi cần phân quyền "chỉ chủ sở hữu bài viết được chỉnh sửa bài viết của họ". 
Đây là ownership check, không thể chỉ dựa trên role hay claim.

Định nghĩa Requirement:
```csharp
public class DocumentEditRequirement : IAuthorizationRequirement { }
```

Định nghĩa Handler (resource-based):
```csharp
public class DocumentEditHandler : AuthorizationHandler<DocumentEditRequirement, Document>
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        DocumentEditRequirement requirement,
        Document resource)
    {
        // Nếu là Admin thì pass
        if (context.User.IsInRole("Admin"))
        {
            context.Succeed(requirement);
            return Task.CompletedTask;
        }

        // Ownership check - resource.OwnerId so với user claim
        var userId = context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        if (userId != null && resource.OwnerId == userId)
        {
            context.Succeed(requirement);
        }

        return Task.CompletedTask;
    }
}
```

Đăng ký handler trong `Program.cs`:
```csharp
builder.Services.AddAuthorization();
builder.Services.AddSingleton<IAuthorizationHandler, DocumentEditHandler>();
```

Sử dụng `IAuthorizationService` trong Controller:
```csharp
public class DocumentsController : Controller
{
    private readonly IAuthorizationService _authorizationService;
    private readonly IDocumentRepository _repo;

    public DocumentsController(IAuthorizationService authorizationService, IDocumentRepository repo)
    {
        _authorizationService = authorizationService;
        _repo = repo;
    }

    [HttpPost]
    public async Task<IActionResult> Edit(Guid id, DocumentEditModel model)
    {
        var doc = await _repo.GetByIdAsync(id);
        if (doc == null) return NotFound();

        var authResult = await _authorizationService.AuthorizeAsync(User, doc, new DocumentEditRequirement());
        if (!authResult.Succeeded) return Forbid();

        // thực hiện update
        // ...
        return Ok();
    }
}
```

Ưu điểm: Cực kỳ linh hoạt, phù hợp API tài nguyên (Blog, File, Order...).
Nhược điểm: Phức tạp hơn.

# Claims Transformation

Dùng IClaimsTransformation để thêm hoặc sửa claim sau khi xác thực.  
Ví dụ: load roles/permissions từ DB và thêm claim khi user login. 

```csharp
public class ClaimsTransformer : IClaimsTransformation
{
    public Task<ClaimsPrincipal> TransformAsync(ClaimsPrincipal principal)
    {
        var id = ((ClaimsIdentity)principal.Identity);
        var permission = GetUserPermissionFromDatabase(id);
        id.AddClaim(new Claim("Permission", permission));
        return Task.FromResult(principal);
    }
}
```

# Best Practices

1. Luôn dùng HTTPS để tránh rò rỉ thông tin quan trọng như token hay cookie.
2. Không tự xác thực JWT thủ công mà luôn dùng middleware chính thức.
3. Không lưu thông tin nhạy cảm trong Claim.
4. Thiết lập thời gian sống (Expire) hợp lý cho JWT.
5. Dùng Refresh Token để gia hạn JWT an toàn.
6. Nên sử dụng Role/Policy caching hợp lý nếu load từ DB.

Hy vọng qua bài viết này, bạn đã hiểu rõ hơn sự khác biệt giữa Authentication 
và Authorization, cũng như cách mà .NET triển khai hai cơ chế này thông qua các middleware, 
handler, scheme và service. 
Bảo mật không chỉ là lớp tường rào, mà là nền tảng giúp hệ thống vận hành an toàn, tin cậy 
và dễ mở rộng. Hãy luôn đảm bảo mọi endpoint, service và hành động trong ứng dụng của 
bạn đều được xác thực và phân quyền đúng cách. 
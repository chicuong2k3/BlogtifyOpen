---
url: [/post/thoat-khoi-bi-kich-legacy-domain-driven-design]
title: "Thoát khỏi Bi kịch Legacy - Domain-Driven Design và hành trình dọn rác"
$attribute: PostMetadata(Id = "d4df8b52-a942-4f47-9cc4-d5c7f7e86dac", Title = "Thoát khỏi Bi kịch Legacy - Domain-Driven Design và hành trình dọn rác", Category = "Phát triển PM", LastModified = "19-10-2025", IsDraft=true)
$layout: BlogContentLayout
---

Ngày 13, thứ Sáu, trời lất phất mưa. Tôi mở mail và thấy dòng 
tiêu đề: "Thông báo chấm dứt hợp đồng". Lý do rất ngắn gọn kiểu: "Hiệu suất chưa đáp ứng yêu cầu".  

Tôi bật cười, không phải vì buồn mà vì thấy... nhẹ nhõm như vừa được giải thoát khỏi 
một mối quan hệ toxic mà mình đã cố níu kéo suốt bấy lâu nay. 
Suốt mấy tháng qua, tôi đã chiến đấu với đống Legacy Code, thứ mà tôi 
tin là đã khiến không ít coder mất ngủ và rụng tóc. Mỗi lần mở stored procedure 
là tôi lại muốn nhập viện điều trị PTSD. Cái cảm giác phải đối phó với hàng ngàn dòng 
SQL được viết từ thời Mark Zuckerberg còn học Harvard đủ khiến 
thần kinh tôi căng như dây đàn. Lướt TikTok thấy các anh tài đất nước hớn hở khoe "Không 
cần biết lập trình vẫn tạo app xịn xò!" khiến tôi cảm thấy mặc cảm vô cùng, 
chỉ ước có con AI nào có thể đọc và sửa giúp tôi cái đống stored procedure này.

Công ty cũ của tôi tự hào gọi hệ thống ấy là "nền tảng ổn định qua nhiều năm". 
Còn tôi thì gọi nó là di tích lịch sử cấp quốc gia =)). Và nhiệm vụ của tôi là 
bảo tồn cái di tích "ngàn năm tuổi" này.

# Hồi ức về thời hoàng kim của Stored Procedure

Trước khi chê, phải hiểu tại sao nó tồn tại. Hồi thập niên 90-2000 Stored Procedure (SP) thực sự có lý do 
để tồn tại. Thập niên 1990–2000, chi phí network còn đắt đỏ, mỗi lần ứng dụng nói chuyện 
với database là tốn 10–100ms. Để tiết kiệm thời gian thì người ta nhét hết logic vào 
trong SP để chạy luôn trong database cho nhanh. 

Khi mở database ra, danh sách SP dài tới mức cần cuộn ba bốn lần chuột vẫn chưa hết... một nửa. 
Những cái tên như `sp_UpdateStock_v3`, `usp_CalculateInventory_old`, 
`sp_GetSupplierAndOrderStuff` khiến tôi toát mồ hôi. 

Tôi tò mò mở một file ra. 

300 dòng, rồi 500 dòng.

Rồi một con quái vật 1200 dòng, không một dòng comment. Chỉ có những câu lệnh IF lồng IF, 
đầy những biến kiểu `@tmp_Calc1`, `@v2_SumTemp` và hàng chục JOIN mà chỉ có tác giả ban đầu 
(nay chắc đã nghỉ hưu trồng rau nuôi cá) mới hiểu nổi. 

Tôi hiểu vì sao thời ấy người ta làm vậy. Không có ORM, mọi thứ đều chạy trên một con 
server to đùng, nơi SP là vị vua trị vì tất cả.

# Khi mỗi người hiểu một kiểu

DDD bắt đầu từ việc hiểu domain, tức là lĩnh vực mà phần mềm đang phục vụ. 
Với hệ thống này, domain là quản lý kho hàng. Trong DDD, domain lại được chia thành 3 loại "Subdomain":
- Core Subdomain: phần quan trọng nhất tạo ra lợi thế cạnh tranh 
như thuật toán dự đoán nhu cầu, tối ưu nhập hàng.
- Supporting Subdomain: phần hỗ trợ giúp core hoạt động như quản lý sản phẩm, nhà cung cấp.
- Generic Subdomain: những thứ ai cũng có không cần sáng tạo lại như đăng nhập, phân quyền, gửi mail.

Nhưng trong hệ thống cũ của tôi, chuyện đó là điều xa xỉ.

Một hôm, sếp giao cho tôi một task tưởng dễ như ăn bánh:
"Kiểm tra lại số liệu tồn kho giữa các hệ thống đang bị lệch nhau."

Có đến ba hệ thống khác nhau cùng quản lý dữ liệu tồn kho:
- ERP: dùng cho kế toán, nhập hàng, báo cáo tài chính.
- Hệ thống bán lẻ (POS): dùng tại cửa hàng, cập nhật số hàng bán mỗi ngày.
- Hệ thống kho trung tâm: quản lý số hàng thực tế trong kho.

Vấn đề là mỗi hệ thống hiểu chữ tồn kho theo một kiểu khác nhau.
- ERP tính luôn cả hàng đang trên đường vận chuyển (vì kế toán coi đó là tài sản).
- POS lại trừ luôn hàng lỗi hoặc hàng đang chờ đổi trả (vì nhân viên cửa hàng chỉ quan tâm hàng còn bán được).
- Kho trung tâm thì chỉ tính số hàng đang nằm thật trên kệ.

ERP báo còn 12000 sản phẩm.  
POS lại hiển thị 9800. Kho vận hành thì khăng khăng chỉ còn 10500. 

Kết quả là hệ thống báo “còn hàng”, khách đặt mua, nhân viên chạy xuống kho thì trống trơn.  
Cũng có lúc hàng đầy kho mà hệ thống lại báo “hết”.  


# ORM xuất hiện nhưng ác mộng vẫn còn

ORM như Hibernate, Entity Framework ra đời. Dev như tôi vui mừng vì không phải viết SQL nữa. 

Nhưng đúng kiểu "chạy trời không khỏi nắng". SP biến mất, nhưng ác mộng mới xuất hiện: 
Anemic Domain Model. 

Entity chỉ có vài dòng property:
```csharp
public class Inventory
{
    public int ProductId { get; set; }
    public int StockLevel { get; set; }
    public int MinStockLevel { get; set; }
    // Không có method nào thể hiện business logic
}
```

Còn tất cả logic thì đổ vào một service khổng lồ 😭:
```csharp
public class InventoryService
{
    public void CheckLowStockAlert() 
    {
        // 2000 dòng code với if-else chi chít
    }
}
```

Khi SP là một "God Procedure" thì giờ ta có "God Service". Tuy khác tên nhưng về bản chất 
vẫn vậy. Mà điều buồn cười là vẫn dùng cùng ngôn ngữ cũ:
`CheckStockLevel`, `UpdateMinStock`, `CalculateInventory_v2`. 
Không ai biết v2 khác gì v1.
Không ai hỏi tại sao MinStock lại khác SafetyStock. 

Sau khi bị sa thải, tôi có thời gian ngồi đọc sách DDD của Eric Evans. Tôi nhận ra vấn đề 
không phải là code đẹp hay xấu, mà là ranh giới không rõ ràng. Trong DDD, ranh giới đó 
được là **Bounded Context**, là phạm vi mà trong đó một model được áp dụng nhất quán. 
Nói dễ hiểu là "Mỗi team, mỗi phần hệ thống nên có ngôn ngữ và model riêng." Ví dụ:
- Inventory Management có khái niệm SafetyStock, ReorderPoint, Warehouse.
- Product Catalog thì có Product, Category, Supplier.
- Order Processing thì có Order, Shipment, Payment.

# Context Map ra đời

Nhưng tách ranh giới chưa đủ. Các bounded context vẫn phải giao tiếp với nhau.
Và chính ở chỗ giao tiếp đó, mâu thuẫn lại nảy sinh.




